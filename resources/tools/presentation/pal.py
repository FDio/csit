# Copyright (c) 2023 Cisco and/or its affiliates.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""CSIT Presentation and Analytics Layer.
"""

import sys
import argparse
import logging

from pal_errors import PresentationError
from specification_parser import Specification
from environment import Environment, clean_environment
from static_content import prepare_static_content
from input_data_parser import InputData
from generator_tables import generate_tables
from generator_plots import generate_plots
from generator_files import generate_files
from generator_report import generate_report
from generator_cpta import generate_cpta
from generator_alerts import Alerting, AlertingError
from convert_xml_json import convert_xml_to_json


OUTPUTS = ("none", "report", "trending", "convert-xml-to-json")


def parse_args():
    """Parse arguments from cmd line.

    :returns: Parsed arguments.
    :rtype: ArgumentParser
    """

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        "-s", "--specification",
        required=True,
        type=str,
        help="Specification YAML file."
    )
    parser.add_argument(
        "-r", "--release",
        default="master",
        type=str,
        help="Release string of the product."
    )
    parser.add_argument(
        "-w", "--week",
        default="1",
        type=str,
        help="Calendar week when the report is published."
    )
    parser.add_argument(
        "-l", "--logging",
        choices=[
            "NOTSET", "DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"
        ],
        default="ERROR",
        help="Logging level."
    )
    parser.add_argument(
        "-f", "--force",
        action="store_true",
        help="Force removing the old build(s) if present."
    )
    parser.add_argument(
        "-o", "--print-all-oper-data",
        action="store_true",
        help="Print all operational data to console. Be careful, the output "
             "can be really long."
    )
    parser.add_argument(
        "-i", "--input-file",
        type=str,
        default="",
        help="XML file generated by RobotFramework which will be processed "
             "instead of downloading the data from Nexus and/or Jenkins. In "
             "this case, the section 'input' in the specification file is "
             "ignored."
    )
    parser.add_argument(
        "-d", "--input-directory",
        type=str,
        default="",
        help="Directory with XML file(s) generated by RobotFramework or with "
             "sub-directories with XML file(s) which will be processed "
             "instead of downloading the data from Nexus and/or Jenkins. In "
             "this case, the section 'input' in the specification file is "
             "ignored."
    )

    return parser.parse_args()


def main():
    """Main function."""

    log_levels = {
        "NOTSET": logging.NOTSET,
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL
    }

    args = parse_args()
    logging.basicConfig(
        format="%(asctime)s: %(levelname)s: %(message)s",
        datefmt="%Y/%m/%d %H:%M:%S",
        level=log_levels[args.logging]
    )

    logging.info("Application started.")

    try:
        spec = Specification(args.specification)
        spec.read_specification()
    except PresentationError as err:
        logging.critical("Finished with error.")
        logging.critical(repr(err))
        return 1

    if spec.output["output"] not in OUTPUTS:
        logging.critical(
            f"The output {spec.output[u'output']} is not supported."
        )
        return 1

    return_code = 1
    try:
        env = Environment(spec.environment, args.force)
        env.set_environment()

        prepare_static_content(spec)

        data = InputData(spec, spec.output["output"])
        if args.input_file:
            data.process_local_file(args.input_file)
        elif args.input_directory:
            data.process_local_directory(args.input_directory)
        else:
            data.download_and_parse_data(repeat=1)

        if args.print_all_oper_data:
            data.print_all_oper_data()

        generate_tables(spec, data)
        generate_plots(spec, data)
        generate_files(spec, data)

        if spec.output["output"] == "report":
            generate_report(args.release, spec, args.week)
        elif spec.output["output"] == "trending":
            sys.stdout.write(generate_cpta(spec, data))
            try:
                alert = Alerting(spec)
                alert.generate_alerts()
            except AlertingError as err:
                logging.warning(repr(err))
        elif spec.output["output"] == "convert-xml-to-json":
            convert_xml_to_json(spec, data)
        else:
            logging.info("No output will be generated.")

        logging.info("Successfully finished.")
        return_code = 0

    except AlertingError as err:
        logging.critical(f"Finished with an alerting error.\n{repr(err)}")
    except PresentationError as err:
        logging.critical(f"Finished with a PAL error.\n{str(err)}")
    except (KeyError, ValueError) as err:
        logging.critical(f"Finished with an error.\n{repr(err)}")
    finally:
        if spec is not None:
            clean_environment(spec.environment)
    return return_code


if __name__ == "__main__":
    sys.exit(main())
