Scratch pad to derive the correct formulas.

First problem: 2D quadratic fit with weights.
We have data points x_a, y_a, v_a, to be taken with weight w_a.
we want to minimize L:
L = Sum_a[1/2*((A +Bx +Cy +Dxx +Exy +Fyy)(x_a, y_a) -v_a)^2 *w_a]
Function G(x,y) = (A +Bx +Cy +Dxx +Exy +Fyy)(x,y):
L = Sum_a[1/2*(G(x_a, y_a) -v_a)^2 *w_a]
Derivatives:
0 = dL/dA = Sum_a[(G -v_a) *w_a]
0 = dL/dB = Sum_a[x*(G -v_a) *w_a]
0 = dL/dC = Sum_a[y*(G -v_a) *w_a]
0 = dL/dD = Sum_a[x*x*(G -v_a) *w_a]
0 = dL/dE = Sum_a[x*y*(G -v_a) *w_a]
0 = dL/dF = Sum_a[y*y*(G -v_a) *w_a]
With sums of argument powers: S{x}{y} = Sum_a[x_a^{}*y_a^{}*w_a]
A*S +B*Sx +C*Sy +D*Sxx +E*Sxy +F*Syy = Sv
A*Sx +B*Sxx +C*Sxy +D*Sxxx +E*Sxxy +F*Sxyy = Sxv
A*Sy +B*Sxy +C*Syy +D*Sxxy +E*Sxyy +F*Syyy = Syv
A*Sxx +B*Sxxx +C*Sxxy +D*Sxxxx +E*Sxxxy +F*Sxxyy = Sxxv
A*Sxy +B*Sxxy +C*Sxyy +D*Sxxxy +E*Sxxyy +F*Sxyyy = Sxyv
A*Syy +B*Sxyy +C*Syyy +D*Sxxyy +E*Sxyyy +F*Syyyy = Syyv
System of linear equations, easy to solve. Left side is even symmetric.
Then finding the minimum of G:
0 = dG/dx = B +2Dx +Ey
0 = dG/dy = C +Ex +2Fy
One again, easy.
The hardest part would be finding the transformation matrix for generation.

Weights. We have 6 parameters, so we need at least 6 points, non-co-quadric.
Say 12 to be safe. Only keep the 12 best so faraway points do not influence.
As usual, do not do tard cutoff. Say, the 12th point should have 1/100 weight
of the first point, and take all points into account.
If constant re-weighting takes time, we can fix generating few point
before recomputing the quadric.

Outliers. There will be low frequency, high weight points, as usually
the tail will not be Gaussian. Handle that by requiring the generator
to stretch more in direction of big outlier, compensate by smaller average weight.

With non-trivial function, 2D quadratic fit is giving quite a bad approximation.
So more direct idea: compute moments of weighted distribution.
2D average as in AvgStdeMetadata avg.
xx and yy moments via m2, but let me check xy:
We want Sum_a[w_a *(x_a -x_avg) *(y_a -y_avg)] =: Vxy
x_avg(n) = x_avg(n-1) +(x_n -x_avg(n-1)) *(w_n /S(n))
dx_n :=(x_n -x_avg(n-1))
x_n -x_avg(n) = x_n -x_avg(n-1) -dx_n*w_n/S_n
x_a -x_avg(n) = x_a -x_avg(n-1) -dx_n*w_n/S_n
Vxy_n =w_n*(x_n -x_avg(n-1) -dx_n*w_n/S_n)*(y_n -y_avg(n-1) -dy_n*w_n/S_n) +
+ Sum_a(n-1)[w_a*(x_a -x_avg(n-1) -dx_n*w_n/S_n)*(y_a -y_avg(n-1) -dy_n*w_n/S_n) =
= w_n*dx_n*dy_n *(1 -w_n/S_n)^2 +Vxy(n-1) -0 -0 +S(n-1)*dx_n*dy_n *(w_n/S_n)^2 =
= Vxy(n-1) +dx_n*dy_n*[w_n *(S(n-1)/S(n))^2 + S(n-1) *(w_n/S_n)^2] =
= Vxy(n-1) +dx_n*dy_n*(w_n*S(n-1)/S_n^2)*[S(n-1) +w_n] =
= Vxy(n-1) +dx_n*dy_n*w_n*S(n-1)/S(n)
Alright, nothing surprising happened.
As usual, I would like to track Axy=Vxy/S
Axy(n) = Vxy(n)/S_n = Vxy(n-1)/S_n +dx_n*dy_n*w_n*S(n-1)/S_n^2 =
= Axy(n-1)*S(n-1)/S_n +dx_n*dy_n*w_n*S(n-1)/S_n^2 =
= [Axy(n-1) +dx_n*dy_n*w_n/S_n]*S(n-1)/S(n)
