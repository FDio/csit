{
  "$id": "https://fd.io/FIXME/CSIT/UTI/test_case/info/0.2.0",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "Schema for info output of test case.",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "duration": {
      "description": "A derived quantity, present only in info output files. Difference between start_time and end_time, in seconds.",
      "$ref": "#/$defs/types/nonnegative_number"
    },
    "dut": {
      "description": "Sub-object encompassing values whose exact schema depends on (usually software) Device Under Test (DUT) used.",
      "allOf": [
        {
          "description": "Common structure shared by all DUT types.",
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "type": {
              "description": "DUT type used, e.g. VPP or DPDK.",
              "type": "string"
            },
            "version": {
              "description": "Version string appropriate to DUT type used.",
              "type": "string"
            }
          },
          "required": [
            "type",
            "version"
          ]
        },
        {
          "oneOf": [
            {
              "description": "Subschema for tests with no DUT, e.g. TRex self-test.",
              "properties": {
                "type": {
                  "const": "none"
                },
                "version": {
                  "const": ""
                }
              }
            },
            {
              "description": "Subschema for DUT type VPP.",
              "properties": {
                "type": {
                  "const": "VPP"
                },
                "version": {
                  "minLength": 1,
                  "comment": "Do we want to require more, e.g. at least two dots?"
                }
              }
            },
            {
              "description": "Subschema for DUT type DPDK.",
              "properties": {
                "type": {
                  "const": "DPDK"
                },
                "version": {
                  "minLength": 1
                }
              }
            }
          ]
        }
      ]
    },
    "end_time": {
      "description": "UTC date and time in RFC 3339 format, specifying calendar time just before test case ended (at the end of test case teardown).",
      "$ref": "#/$defs/types/date_time"
    },
    "log": {
      "description": "No log items are implemented in the current version, but the (empty) list is present to simplify logic in multi-version importers.",
      "$ref": "#/$defs/types/empty_array"
    },
    "message": {
      "description": "If status is PASS, this property is not present. Otherwise, value taken directly from TEST_MESSAGE Robot variable, read at the end of test case (teardown). It contains information from the exception that caused the failure, probably with additional exceptions from teardown keywords.",
      "type": "string"
    },
    "result": {
      "type": "object",
      "allOf": [
        {
          "description": "Sub-schema common for all cases, just result type identifier.",
          "properties": {
            "type": {
              "description": "Identifier of which result type case is applied.",
              "type": "string"
            }
          },
          "required": [
            "type"
          ]
        },
        {
          "oneOf": [
            {
              "description": "Result type for unknown case. This case represents a test with no specific result (outside message), e.g. device test; or a test with result not parsed into this version of model yet, e.g. GSO test.",
              "additionalProperties": false,
              "properties": {
                "type": {
                  "const": "unknown"
                }
              }
            },
            {
              "description": "Result type MRR case.",
              "comment": "TODO: Add description with link to methodology for MRR. TODO: Add multiplicity field, so PAL can detect incomplete samples.",
              "additionalProperties": false,
              "properties": {
                "type": {
                  "const": "mrr"
                },
                "receive_rate": {
                  "description": "The results refer to receive rates for multiple MRR trials. For PPS, these are aggregate (bidirectional) rates. Currently, the tests are exporting approximated receive rates. That means the actual trial duration is measured (as opposed to trusting traffic generator to honor its target duration), so the resulting values contain noise from time measurement, and can be lower than the real performance (due to various time overheads). Bandwidth values are supported, but currently Robot does not export them.",
                  "$ref": "#/$defs/types/rate_list_with_bandwidth"
                }
              },
              "required": [
                "type",
                "receive_rate"
              ]
            },
            {
              "description": "Result type NDRPDR case.",
              "comment": "TODO: Add description with link to methodology for NDRPDR.",
              "additionalProperties": false,
              "properties": {
                "type": {
                  "const": "ndrpdr"
                },
                "ndr": {
                  "description": "The results refer to search for NDR (Non Drop Rate). For PPS, this is aggregate (bidirectional) rate. Each bound was used as the target load value in a full-duration trial measurement. The accepted loss ratio for NDR is exact zero. Note that packets the Traffic Generator did not send are also counted as lost packets.",
                  "$ref": "#/$defs/macros/lower_and_upper_rate"
                },
                "pdr": {
                  "description": "The results refer to search for PDR (Partial Drop Rate). For PPS, this is aggregate (bidirectional) rate. Each bound was used as the target load value in a full-duration trial measurement. The accepted loss ratio for PDR is 0.5%. Note that packets the Traffic Generator did not send are also counted as lost packets.",
                  "$ref": "#/$defs/macros/lower_and_upper_rate"
                },
                "latency_forward": {
                  "description": "Object with results related to latency part of NDRPDR test, for forward traffic direction. It is the direction used in unidirectional traffic profiles. ASTF profiles and IMIX STL profiles do not support latency information, so for those tests this object is missing. It is also missing if Traffic Generator fails to return valid latency results for any other reasons, e.g. latency rate is too high for CPU/NIC used.",
                  "$ref": "#/$defs/macros/latency_for_loads"
                },
                "latency_reverse": {
                  "description": "Object with results related to latency part of NDRPDR test, for reverse traffic diration. This object is not present when unidirectional traffic profiles are used. ASTF profiles and IMIX STL profiles do not support latency information, so for those tests this object is missing. It is also missing if Traffic Generator fails to return valid latency results for any other reasons, e.g. latency rate is too high for CPU/NIC used.",
                  "$ref": "#/$defs/macros/latency_for_loads"
                }
              },
              "required": [
                "type",
                "ndr",
                "pdr"
              ]
            },
            {
              "description": "Result type SOAK case.",
              "comment": "TODO: Add description with link to methodology for SOAK.",
              "additionalProperties": false,
              "properties": {
                "type": {
                  "const": "soak"
                },
                "critical_rate": {
                  "description": "The results refer to bayesian estimate of critical rate corresponding to 10^-7 average loss ratio. For PPS, this is aggregate (bidirectional) rate. The bounds are based on trial measurement results, but are not equal to any target load used. Note that packets the Traffic Generator did not send are also counted as lost packets.",
                  "$ref": "#/$defs/macros/lower_and_upper_rate"
                }
              },
              "required": [
                "type",
                "critical_rate"
              ]
            }
          ]
        }
      ]
    },
    "robot": {
      "description": "Sub-object encompassing values whose exact schema depend on whether the robot test passed or failed (before export and validation).",
      "allOf": [
        {
          "description": "Common structure not depending on test status.",
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "status": {
              "description": "Value taken directly from TEST_STATUS Robot variable. It is PASS or FAIL, read at the end of test case (in test teardown, before export and validation).",
              "type": "string"
            },
            "message": {
              "description": "If status is PASS, this value is empty. Otherwise, value taken directly from TEST_MESSAGE Robot variable, read at the end of test case (in test teardown, before export and validation). It contains information from the exception that caused the failure, probably with additional exceptions from teardown keywords.",
              "type": "string"
            }
          },
          "required": [
            "status",
            "message"
          ]
        },
        {
          "oneOf": [
            {
              "description": "Subschema for passing tests.",
              "properties": {
                "status": {
                  "const": "PASS"
                },
                "message": {
                  "const": ""
                }
              }
            },
            {
              "description": "Subschema for failing tests.",
              "properties": {
                "status": {
                  "const": "FAIL"
                },
                "message": {
                  "minLength": 1
                }
              }
            }
          ]
        }
      ]
    },
    "start_time": {
      "description": "UTC date and time in RFC 3339 format, specifying calendar time just after test case started (at the start of test setup).",
      "$ref": "#/$defs/types/date_time"
    },
    "suite_id": {
      "description": "A derived quantity, present only in info output files. This property has a value, converted from suite name by replacing spaces with underscores and converting to lowercase.",
      "type": "string",
      "comment": "TODO: Test with underscores and spaces, both in suite and test."
    },
    "suite_name": {
      "description": "Value taken directly from SUITE_NAME Robot variable. It consists of PascalCase names for the suite level delimited by dot. Each name may contain spaces (converted from underscores in source).",
      "type": "string"
    },
    "tags": {
      "description": "The list of strings comes directly from Robot variable TEST_TAGS. The content should include both static and dynamic tags at the end of test case (teardown).",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "test_documentation": {
      "description": "Value taken directly from TEST_DOCUMENTATION Robot variable. The content is what you see in suite file at test case definition, which is usually empty as CSIT uses data driven test cases.",
      "type": "string"
    },
    "test_id": {
      "description": "A derived quantity, present only in info output files. This property has a value, composed from suite name and test name connected with dot. Also, any space is replaced by underscore and letetrs are converted to lower case.",
      "comment": "TODO: Test with underscores and spaces, both in suite and test.",
      "type": "string"
    },
    "test_name": {
      "description": "Value taken directly from TEST_NAME Robot variable. It consists of PascalCase name of this test case.",
      "type": "string"
    },
    "version": {
      "description": "CSIT model version (semver format) the exporting code adhered to.",
      "type": "string",
      "const": "1.0.0"
    }
  },
  "required": [
    "duration",
    "dut",
    "end_time",
    "log",
    "result",
    "robot",
    "start_time",
    "suite_id",
    "suite_name",
    "tags",
    "test_documentation",
    "test_id",
    "test_name",
    "version"
  ],
  "$defs": {
    "types": {
      "nonnegative_number": {
        "type": "number",
        "minimum": 0
      },
      "nonnegative_integer": {
        "type": "integer",
        "minimum": 0
      },
      "positive_integer": {
        "type": "integer",
        "minimum": 1
      },
      "date_time": {
        "type": "string",
        "format": "date-time"
      },
      "empty_array": {
        "type": "array",
        "maxItems": 0
      },
      "rate_unit": {
        "description": "Packets per second (pps) or connections per second (cps).",
        "type": "string",
        "enum": [
          "pps",
          "cps"
        ]
      },
      "bandwidth_unit": {
        "description": "Unit of measurement for bandwidth values. Currently a constant, but later versions of model may allow more units.",
        "enum": [
          "bps"
        ]
      },
      "value_with_unit": {
        "description": "Reusable composite type, value together with its unit of measurement.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "value": {
            "description": "Numeric value, context specified elsewhere. The only assumption is that the value is positive.",
            "$ref": "#/$defs/types/nonnegative_number"
          },
          "unit": {
            "description": "Unit of measurement for the value. Context and allowed values are specified elsewhere.",
            "type": "string"
          }
        },
        "required": [
          "value",
          "unit"
        ]
      },
      "rate_without_bandwidth": {
        "description": "Reusable type, for various rate quantites.",
        "allOf": [
          {
            "$ref": "#/$defs/types/value_with_unit"
          },
          {
            "properties": {
              "value": {
                "description": "Unless specified otherwise, this is the aggregated rate (sum of both traffic directions). Depending on the usage, the value can express intended load, offered load, receive rate, and various approximations or estimated bounds thereof."
              },
              "unit": {
                "description": "A transaction rate unit the value is expressed in.",
                "$ref": "#/$defs/types/rate_unit"
              }
            }
          }
        ]
      },
      "bandwidth": {
        "description": "Reusable type, for various bandwidth quantites.",
        "allOf": [
          {
            "$ref": "#/$defs/types/value_with_unit"
          },
          {
            "properties": {
              "value": {
                "description": "Bandwidth value computed from the corresponding rate.",
                "comment": "TODO: Add link explaining our L1 bandwidth calculation."
              },
              "unit": {
                "$ref": "#/$defs/types/bandwidth_unit"
              }
            }
          }
        ]
      },
      "rate_with_bandwidth": {
        "description": "Reusable composite type, joining primary rate with optional derived bandwidth. Not all test types currently compute bandwidth, even if rate unit is pps.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "rate": {
            "$ref": "#/$defs/types/rate_without_bandwidth"
          },
          "bandwidth": {
            "$ref": "#/$defs/types/bandwidth"
          }
        },
        "required": [
          "rate"
        ]
      },
      "values_with_unit_and_stats": {
        "description": "Reusable composite type, multiple values together with their unit of measurement and derived statistics.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "values": {
            "description": "List of values of the same unit, useful for MRR.",
            "type": "array",
            "minItmes": 1,
            "items": {
              "description": "Numeric value, context specified elsewhere. The only assumption is that the value is positive.",
              "$ref": "#/$defs/types/positive_number"
            }
          },
          "avg": {
            "description": "A derived quantity, present only in info output files. It is the arithmetic average of the values list.",
            "$ref": "#/$defs/types/positive_number"
          },
          "stdev": {
            "description": "A derived quantity, present only in info output files. It is the standard deviation for the values list, as computed by jumpavg library.",
            "$ref": "#/$defs/types/nonnegative_number"
          },
          "unit": {
            "description": "Unit of measurement for the values. Context and allowed values are specified elsewhere.",
            "type": "string"
          }
        },
        "required": [
          "values",
          "avg",
          "stdev",
          "unit"
        ]
      },
      "rate_list_without_bandwidth": {
        "description": "Reusable composite type, multiple rate values.",
        "allOf": [
          {
            "$ref": "#/$defs/types/value_list_with_unit_and_stats"
          },
          {
            "properties": {
              "values": {
                "items": {
                  "description": "Unless specified otherwise, this is the aggregated rate (sum of both traffic directions). Depending on the usage, the value can express intended load, offered load, receive rate, and various approximations or estimated bounds thereof."
                }
              },
              "unit": {
                "$ref": "#/$defs/types/rate_unit"
              }
            }
          }
        ]
      },
      "bandwidth_list": {
        "description": "Reusable composite type, multiple bandwidth values. This is a derived entity, thus it only appears in info output, and only if rate unit is pps.",
        "comment": "TODO: Add link explaining our L1 bandwidth calculation.",
        "allOf": [
          {
            "$ref": "#/$defs/types/value_list_with_unit_and_stats"
          },
          {
            "properties": {
              "values": {
                "items": {
                  "description": "Unless specified otherwise, this is the aggregated bandwidth (sum of both traffic directions). Depending on the usage, the value can express intended load, offered load, receive rate, and various approximations or estimated bounds thereof."
                }
              },
              "unit": {
                "$ref": "#/$defs/types/bandwidth_unit"
              }
            }
          }
        ]
      },
      "rate_list_with_bandwidth": {
        "description": "Reusable composite type, joining primary rates with optional derived bandwidths (and stats). No test types currently computes the bandwidth part.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "rate": {
            "$ref": "#/$defs/types/rate_list_without_bandwidth"
          },
          "bandwidth": {
            "$ref": "#/$defs/types/bandwidth_list"
          }
        },
        "required": [
          "rate"
        ]
      }
    },
    "macros": {
      "lower_and_upper_rate": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "lower": {
            "description": "The lower bound (or min_rate) for the estimate of a particular searched value.",
            "$ref": "#/$defs/types/rate_with_bandwidth"
          },
          "upper": {
            "description": "The upper bound (or max_rate) for the estimate of a particular searched value.",
            "$ref": "#/$defs/types/rate_with_bandwidth"
          }
        },
        "required": [
          "lower",
          "upper"
        ]
      },
      "latency_numbers": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "min": {
            "description": "Rounded minimal latency time measured in this trial. See unit property for the unit of measurement.",
            "$ref": "#/$defs/types/nonnegative_integer"
          },
          "max": {
            "description": "Rounded maximal latency time measured in this trial. See unit property for the unit of measurement. Zero value is not allowed, as that is one of symptoms of Traffic Generator failing to get proper latency.",
            "$ref": "#/$defs/types/positive_integer"
          },
          "avg": {
            "description": "Rounded average latency time measured in this trial. See unit property for the unit of measurement.",
            "$ref": "#/$defs/types/nonnegative_integer"
          },
          "hdrh": {
            "description": "Base64-encoded compressed representation of HDRHistogram of all latency sample times encountered in this latency trial. See unit property for the unit of measurement. Note that some bins can be several units wide.",
            "comment": "TODO: Add a link to URL explaining how to decode the data?",
            "type": "string"
          },
          "unit": {
            "description": "Unit of measurement for latency times. Currently a constant, but later versions of the model may allow more values.",
            "type": "string",
            "enum": [
              "us"
            ]
          }
        },
        "required": [
          "avg",
          "hdrh",
          "max",
          "min",
          "unit"
        ]
      },
      "latency_for_loads": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "pdr_0": {
            "description": "Object related to latency measurement performed at minimal rate (currently 9000 pps per direction).",
            "$ref": "#/$defs/macros/latency_numbers"
          },
          "pdr_10": {
            "description": "Object related to latency measurement performed at 10% of PDR lower bound, if needed rounded up to minimal rate (currently 9000 pps per direction).",
            "$ref": "#/$defs/macros/latency_numbers"
          },
          "pdr_50": {
            "description": "Object related to latency measurement performed at 50% of PDR lower bound, if needed rounded up to minimal rate (currently 9000 pps per direction).",
            "$ref": "#/$defs/macros/latency_numbers"
          },
          "pdr_90": {
            "description": "Object related to latency measurement performed at 90% of PDR lower bound, if needed rounded up to minimal rate (currently 9000 pps per direction).",
            "$ref": "#/$defs/macros/latency_numbers"
          }
        },
        "required": [
          "pdr_0",
          "pdr_10",
          "pdr_50",
          "pdr_90"
        ]
      }
    }
  }
}