{
  "$id": "https://fd.io/FIXME/CSIT/UTI/test_case/info/1.2.0",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "Schema for info output of test case.",
  "allOf": [
    {
      "description": "The main structure, without conditional relations between fields yet.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "duration": {
          "description": "A derived quantity, present only in info output files. Difference between start_time and end_time, in seconds.",
          "$ref": "#/$defs/nonnegative_float"
        },
        "dut_type": {
          "description": "DUT type used, e.g. VPP or DPDK.",
          "type": "string"
        },
        "dut_version": {
          "description": "Version string appropriate to DUT type used.",
          "type": "string"
        },
        "end_time": {
          "description": "UTC date and time in RFC 3339 format, specifying calendar time just before test case ended (at the end of test case teardown).",
          "$ref": "#/$defs/date_time"
        },
        "hosts": {
          "description": "Array of hosts this test interacted with. This can be used for identifying testbed number. Valid tests shoud interact with at least one DUT or TG. The array is usually sorted, but that is not a requirement.",
          "type": "array",
          "minItems": 1,
          "items": {
            "description": "Host identifier, usually numeric IPv4 address.",
            "type": "string"
          }
        },
        "log": {
          "description": "No log items are implemented in the current version, but the (empty) list is present to simplify logic in multi-version importers.",
          "$ref": "#/$defs/empty_array"
        },
        "message": {
          "description": "If passed is true, this value is empty. Otherwise, value taken directly from TEST_MESSAGE Robot variable, read at the end of test case (in test teardown, before export and validation). It contains information from the exception that caused the failure, probably with additional exceptions from teardown keywords.",
          "type": "string"
        },
        "passed": {
          "description": "Value set accordingly to TEST_STATUS Robot variable, true if and only if the status is \"PASS\". The status is read at the end of test case (in test teardown, before export and validation).",
          "type": "boolean"
        },
        "result": {
          "type": "object",
          "allOf": [
            {
              "description": "Sub-schema common for all result types, only the result type identifier defined here.",
              "properties": {
                "type": {
                  "description": "Identifier of which result type case is applied.",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ]
            },
            {
              "oneOf": [
                {
                  "$ref": "#/$defs/unknown_result"
                },
                {
                  "$ref": "#/$defs/mrr_result"
                },
                {
                  "$ref": "#/$defs/ndrpdr_result"
                },
                {
                  "$ref": "#/$defs/soak_result"
                },
                {
                  "$ref": "#/$defs/reconf_result"
                },
                {
                  "$ref": "#/$defs/hoststack_ab_result"
                },
                {
                  "$ref": "#/$defs/hoststack_iperf3_result"
                },
                {
                  "$ref": "#/$defs/hoststack_vpp_echo_result"
                }
              ]
            }
          ]
        },
        "start_time": {
          "description": "UTC date and time in RFC 3339 format, specifying calendar time just after test case started (at the start of test setup).",
          "$ref": "#/$defs/date_time"
        },
        "tags": {
          "description": "The list of strings comes directly from Robot variable TEST_TAGS. The content should include both static and dynamic tags at the end of test case (teardown).",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "test_documentation": {
          "description": "Value taken directly from TEST_DOCUMENTATION Robot variable. The content is what you see in suite file at test case definition, which is usually empty as CSIT uses data driven test cases.",
          "type": "string"
        },
        "test_id": {
          "description": "A derived quantity, present only in info output files. It is the most complete and unique identifier for a test case. This property has a value, of the following form: {suite_name}.{test_name} Here, suite name comes from SUITE_NAME robot variable, test name comes from TEST_NAME robot variable, but both are converted to lower case, and spaces are replaced by underscores.",
          "type": "string",
          "minLength": 3
        },
        "test_name_long": {
          "description": "A derived quantity, present only in info output files. This property has a value, of the following form: {nic_short_name}-{frame_size}-{threads_and_cores}-{suite_part} Here, suite part is very similar to suite tag, but additionally may contain a prefix describing NIC driver used (if it is not the default one, drv_vfio_pci for VPP tests). Any space is replaced by underscore and letters are lower case.",
          "type": "string",
          "minLength": 3
        },
        "test_name_short": {
          "description": "A derived quantity, present only in info output files. This property has a value very similar to suite tag, but additionally may contain a prefix describing NIC driver used (if it is not the default one, drv_vfio_pci for VPP tests). Any space is replaced by underscore and letters are lower case.",
          "type": "string",
          "minLength": 3
        },
        "test_type": {
          "description": "A derived quantity, present only in info output files. Test type identifier, PAL uses it to group similar tests, e.g. for comparison tables. Ideally, this information should be parseable from test name, but the current naming scheme is not simple/consistent enough. The current implementation queries the robot test tags. The resulting value is frequently identical to result type, but this schema version does not require any relation there, as PAL may want to group tests differently.",
          "type": "string",
          "enum": [
            "device",
            "gso",
            "hoststack",
            "mrr",
            "ndrpdr",
            "reconf",
            "soak",
            "vsap"
          ]
        },
        "version": {
          "description": "CSIT model version (semver format) the exporting code adhered to.",
          "type": "string",
          "const": "1.2.0"
        }
      },
      "required": [
        "duration",
        "dut_type",
        "dut_version",
        "end_time",
        "hosts",
        "log",
        "message",
        "passed",
        "result",
        "start_time",
        "tags",
        "test_documentation",
        "test_id",
        "test_name_long",
        "test_name_short",
        "test_type",
        "version"
      ]
    },
    {
      "description": "Sub-schema validating relation between status and message.",
      "oneOf": [
        {
          "description": "Sub-schema for passing tests, message has to be empty.",
          "type": "object",
          "properties": {
            "passed": {
              "const": true
            },
            "message": {
              "const": ""
            }
          }
        },
        {
          "description": "Sub-schema for failing tests, mesage cannot be empty.",
          "type": "object",
          "properties": {
            "passed": {
              "const": false
            },
            "message": {
              "minLength": 1
            }
          }
        }
      ]
    },
    {
      "description": "Sub-schema validating relation between dut_type and dut_version.",
      "oneOf": [
        {
          "description": "Sub-schema for tests with no DUT, e.g. TRex self-test.",
          "type": "object",
          "properties": {
            "dut_type": {
              "const": "none"
            },
            "dut_version": {
              "const": ""
            }
          }
        },
        {
          "description": "Sub-schema for DUT type VPP.",
          "type": "object",
          "properties": {
            "dut_type": {
              "const": "VPP"
            },
            "dut_version": {
              "minLength": 1
            }
          }
        },
        {
          "description": "Sub-schema for DUT type DPDK.",
          "type": "object",
          "properties": {
            "dut_type": {
              "const": "DPDK"
            },
            "dut_version": {
              "minLength": 1
            }
          }
        }
      ]
    }
  ],
  "$defs": {
    "nonnegative_float": {
      "type": "number",
      "minimum": 0
    },
    "positive_float": {
      "type": "number",
      "exclusiveMinimum": 0
    },
    "nonnegative_integer": {
      "type": "integer",
      "minimum": 0
    },
    "positive_integer": {
      "type": "integer",
      "minimum": 1
    },
    "date_time": {
      "type": "string",
      "format": "date-time"
    },
    "empty_array": {
      "type": "array",
      "maxItems": 0
    },
    "rate_unit": {
      "description": "Packets per second (pps) or connections per second (cps).",
      "type": "string",
      "enum": [
        "pps",
        "cps"
      ]
    },
    "bandwidth_unit": {
      "description": "Unit of measurement for bandwidth values. Currently a constant, but later versions of model may allow more units.",
      "enum": [
        "bps"
      ]
    },
    "value_with_unit": {
      "description": "Reusable composite type, value together with its unit of measurement.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "value": {
          "description": "Numeric value, context specified elsewhere. The only assumption is that value is not negative.",
          "$ref": "#/$defs/nonnegative_float"
        },
        "unit": {
          "description": "Unit of measurement for the value. Context and allowed values are specified elsewhere.",
          "type": "string"
        }
      },
      "required": [
        "value",
        "unit"
      ]
    },
    "rate_without_bandwidth": {
      "description": "Reusable type, for various rate quantites.",
      "allOf": [
        {
          "$ref": "#/$defs/value_with_unit"
        },
        {
          "properties": {
            "value": {
              "description": "Unless specified otherwise, this is the aggregated rate (sum of both traffic directions). Depending on the usage, the value can express intended load, offered load, receive rate, and various approximations or estimated bounds thereof."
            },
            "unit": {
              "description": "A transaction rate unit the value is expressed in.",
              "$ref": "#/$defs/rate_unit"
            }
          }
        }
      ]
    },
    "bandwidth": {
      "description": "Reusable type, for various bandwidth quantites.",
      "allOf": [
        {
          "$ref": "#/$defs/value_with_unit"
        },
        {
          "properties": {
            "value": {
              "description": "Bandwidth value computed from the corresponding rate."
            },
            "unit": {
              "$ref": "#/$defs/bandwidth_unit"
            }
          }
        }
      ]
    },
    "rate_with_bandwidth": {
      "description": "Reusable composite type, joining primary rate with optional derived bandwidth. Not all test types currently compute bandwidth, even if rate unit is pps.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "rate": {
          "$ref": "#/$defs/rate_without_bandwidth"
        },
        "bandwidth": {
          "$ref": "#/$defs/bandwidth"
        }
      },
      "required": [
        "rate"
      ]
    },
    "value_list_with_unit_and_stats": {
      "description": "Reusable composite type, multiple values together with their unit of measurement and derived statistics.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "values": {
          "description": "List of values of the same unit, useful for MRR.",
          "type": "array",
          "minItmes": 1,
          "items": {
            "description": "Numeric value, context specified elsewhere. The only assumption is that the value is nonnegative.",
            "$ref": "#/$defs/nonnegative_float"
          }
        },
        "avg": {
          "description": "A derived quantity, present only in info output files. It is the arithmetic average of the values list.",
          "$ref": "#/$defs/nonnegative_float"
        },
        "stdev": {
          "description": "A derived quantity, present only in info output files. It is the standard deviation for the values list, as computed by jumpavg library.",
          "$ref": "#/$defs/nonnegative_float"
        },
        "unit": {
          "description": "Unit of measurement for the values. Context and allowed values are specified elsewhere.",
          "type": "string"
        }
      },
      "required": [
        "values",
        "avg",
        "stdev",
        "unit"
      ]
    },
    "rate_list_without_bandwidth": {
      "description": "Reusable composite type, multiple rate values.",
      "allOf": [
        {
          "$ref": "#/$defs/value_list_with_unit_and_stats"
        },
        {
          "properties": {
            "values": {
              "items": {
                "description": "Unless specified otherwise, this is the aggregated rate (sum of both traffic directions). Depending on the usage, the value can express intended load, offered load, receive rate, and various approximations or estimated bounds thereof."
              }
            },
            "unit": {
              "$ref": "#/$defs/rate_unit"
            }
          }
        }
      ]
    },
    "bandwidth_list": {
      "description": "Reusable composite type, multiple bandwidth values. This is a derived entity, thus it only appears in info output, and only if rate unit is pps.",
      "allOf": [
        {
          "$ref": "#/$defs/value_list_with_unit_and_stats"
        },
        {
          "properties": {
            "values": {
              "items": {
                "description": "Unless specified otherwise, this is the aggregated bandwidth (sum of both traffic directions). Depending on the usage, the value can express intended load, offered load, receive rate, and various approximations or estimated bounds thereof."
              }
            },
            "unit": {
              "$ref": "#/$defs/bandwidth_unit"
            }
          }
        }
      ]
    },
    "rate_list_with_bandwidth": {
      "description": "Reusable composite type, joining primary rates with optional derived bandwidths (and stats). No test types currently computes the bandwidth part.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "rate": {
          "$ref": "#/$defs/rate_list_without_bandwidth"
        },
        "bandwidth": {
          "$ref": "#/$defs/bandwidth_list"
        }
      },
      "required": [
        "rate"
      ]
    },
    "lower_and_upper_rate": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "lower": {
          "description": "The lower bound (or min_rate) for the estimate of a particular searched value.",
          "$ref": "#/$defs/rate_with_bandwidth"
        },
        "upper": {
          "description": "The upper bound (or max_rate) for the estimate of a particular searched value.",
          "$ref": "#/$defs/rate_with_bandwidth"
        }
      },
      "required": [
        "lower",
        "upper"
      ]
    },
    "latency_numbers": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "min": {
          "description": "Rounded minimal latency time measured in this trial. See unit property for the unit of measurement.",
          "$ref": "#/$defs/nonnegative_integer"
        },
        "max": {
          "description": "Rounded maximal latency time measured in this trial. See unit property for the unit of measurement. Zero value is not allowed, as that is one of symptoms of Traffic Generator failing to get proper latency.",
          "$ref": "#/$defs/positive_integer"
        },
        "avg": {
          "description": "Rounded average latency time measured in this trial. See unit property for the unit of measurement.",
          "$ref": "#/$defs/nonnegative_integer"
        },
        "hdrh": {
          "description": "Base64-encoded compressed representation of HDRHistogram of all latency sample times encountered in this latency trial. See unit property for the unit of measurement. Note that some bins can be several units wide.",
          "type": "string"
        },
        "unit": {
          "description": "Unit of measurement for latency times. Currently a constant, but later versions of the model may allow more values.",
          "type": "string",
          "enum": [
            "us"
          ]
        }
      },
      "required": [
        "avg",
        "hdrh",
        "max",
        "min",
        "unit"
      ]
    },
    "latency_for_loads": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "pdr_0": {
          "description": "Object related to latency measurement performed at minimal rate (currently 9000 pps per direction).",
          "$ref": "#/$defs/latency_numbers"
        },
        "pdr_10": {
          "description": "Object related to latency measurement performed at 10% of PDR lower bound, if needed rounded up to minimal rate (currently 9000 pps per direction).",
          "$ref": "#/$defs/latency_numbers"
        },
        "pdr_50": {
          "description": "Object related to latency measurement performed at 50% of PDR lower bound, if needed rounded up to minimal rate (currently 9000 pps per direction).",
          "$ref": "#/$defs/latency_numbers"
        },
        "pdr_90": {
          "description": "Object related to latency measurement performed at 90% of PDR lower bound, if needed rounded up to minimal rate (currently 9000 pps per direction).",
          "$ref": "#/$defs/latency_numbers"
        }
      },
      "required": [
        "pdr_0",
        "pdr_10",
        "pdr_50",
        "pdr_90"
      ]
    },
    "unknown_result": {
      "description": "Sub-schema for unknown result type. This case represents a test with no specific result (outside message), e.g. device test; or a test with result not parsed into this version of model yet, e.g. GSO test.",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "unknown"
        }
      }
    },
    "mrr_result": {
      "description": "Sub-schema for MRR result type.",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "mrr"
        },
        "receive_rate": {
          "description": "The results refer to receive rates for multiple MRR trials. For PPS, these are aggregate (bidirectional) rates. Currently, the tests are exporting approximated receive rates. That means the actual trial duration is measured (as opposed to trusting traffic generator to honor its target duration), so the resulting values contain noise from time measurement, and can be lower than the real performance (due to various time overheads). Bandwidth values are supported, but currently Robot does not export them.",
          "$ref": "#/$defs/rate_list_with_bandwidth"
        }
      },
      "required": [
        "receive_rate"
      ]
    },
    "ndrpdr_result": {
      "description": "Sub-schema for NDRPDR result type.",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "ndrpdr"
        },
        "ndr": {
          "description": "The results refer to search for NDR (Non Drop Rate). For PPS, this is aggregate (bidirectional) rate. Each bound was used as the target load value in a full-duration trial measurement. The accepted loss ratio for NDR is exact zero. Note that packets the Traffic Generator did not send are also counted as lost packets.",
          "$ref": "#/$defs/lower_and_upper_rate"
        },
        "pdr": {
          "description": "The results refer to search for PDR (Partial Drop Rate). For PPS, this is aggregate (bidirectional) rate. Each bound was used as the target load value in a full-duration trial measurement. The accepted loss ratio for PDR is 0.5%. Note that packets the Traffic Generator did not send are also counted as lost packets.",
          "$ref": "#/$defs/lower_and_upper_rate"
        },
        "latency_forward": {
          "description": "Object with results related to latency part of NDRPDR test, for forward traffic direction. It is the direction used in unidirectional traffic profiles. ASTF profiles and IMIX STL profiles do not support latency information, so for those tests this object is missing. It is also missing if Traffic Generator fails to return valid latency results for any other reasons, e.g. latency rate is too high for CPU/NIC used.",
          "$ref": "#/$defs/latency_for_loads"
        },
        "latency_reverse": {
          "description": "Object with results related to latency part of NDRPDR test, for reverse traffic diration. This object is not present when unidirectional traffic profiles are used. ASTF profiles and IMIX STL profiles do not support latency information, so for those tests this object is missing. It is also missing if Traffic Generator fails to return valid latency results for any other reasons, e.g. latency rate is too high for CPU/NIC used.",
          "$ref": "#/$defs/latency_for_loads"
        }
      },
      "required": [
        "ndr",
        "pdr"
      ]
    },
    "soak_result": {
      "description": "Sub-schema for SOAK result type.",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "soak"
        },
        "critical_rate": {
          "description": "The results refer to bayesian estimate of critical rate corresponding to average loss ratio of 10^-7. For PPS, this is aggregate (bidirectional) rate. The bounds are computed from trial measurement results, but are not equal to any target load used. Note that packets the Traffic Generator did not send are also counted as lost packets.",
          "$ref": "#/$defs/lower_and_upper_rate"
        }
      },
      "required": [
        "critical_rate"
      ]
    },
    "reconf_result": {
      "description": "Sub-schema for RECONF result type.",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "reconf"
        },
        "packet_rate": {
          "description": "Load used when reconfiguring, found as NDR lower bound. This is aggregate (bidirectional) rate. Note that packets the Traffic Generator did not send are also counted as lost packets.",
          "$ref": "#/$defs/rate_with_bandwidth"
        },
        "packet_loss": {
          "description": "Number of packets lost during reconfiguration.",
          "$ref": "#/$defs/nonnegative_integer"
        },
        "time_loss": {
          "description": "A derived quantity, present only in info files. Packet loss divided by packet rate. If the DUT keeps dropping packets for this long (while forwarding with no losses otherwise), it results in the same number of packets lost.",
          "$ref": "#/$defs/nonnegative_float"
        }
      },
      "required": [
        "packet_loss",
        "packet_rate",
        "time_loss"
      ]
    },
    "hoststack_ab_result": {
      "description": "Result type HOSTSTACK AB case. This is used for VSAP tests which use AB as a client and NGINX as a server.",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "hoststack_ab"
        },
        "object": {
          "description": "The structured object holding the parsed values obtained from the AB tool output.",
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "completed_requests": {
              "description": "How many HTTP requests were completed.",
              "$ref": "#/$defs/positive_integer"
            },
            "failed_requests": {
              "description": "How many HTTP requests failed. Request failures do not cause overall test failure, especially for CPS test.",
              "$ref": "#/$defs/nonnegative_integer"
            },
            "latency_unit": {
              "description": "Unit of measurement for latency.",
              "enum": [
                "ms"
              ]
            },
            "latency_value": {
              "description": "Latency value as reported by AB, probably the HTTP response delay averaged over all HTTP requests.",
              "$ref": "#/$defs/positive_float"
            },
            "protocol": {
              "description": "Protocol used by AB to transport requests.",
              "enum": [
                "HTTP",
                "HTTPS"
              ]
            },
            "quantity": {
              "description": "Specifies the main quantity of interest. CPS tests measure connections per second (connections are closed and reopened after each response), RPS tests measure requests per second (each client worker reuses its connection without closing it between requests).",
              "enum": [
                "cps",
                "rps"
              ]
            },
            "rate": {
              "description": "The numeric value measured for the main quantity of interest (cps or rps).",
              "$ref": "#/$defs/positive_float"
            },
            "total_bytes": {
              "description": "How many bytes were transferred.",
              "$ref": "#/$defs/positive_float"
            },
            "transfer_rate": {
              "description": "Numeric value measured for the goodput.",
              "$ref": "#/$defs/positive_float"
            },
            "transfer_unit": {
              "description": "The unit of the goodput measurement.",
              "enum": [
                "Kbytes/sec"
              ]
            }
          },
          "required": [
            "completed_requests",
            "failed_requests",
            "latency_unit",
            "latency_value",
            "protocol",
            "quantity",
            "rate",
            "total_bytes",
            "transfer_rate",
            "transfer_unit"
          ]
        }
      },
      "required": [
        "object"
      ]
    },
    "hoststack_failed_object": {
      "description": "Sub-schema for part of the result when a tool reports failure, so the output is probably not parseable into expected properties. This covers both iperf3 and vpp_echo output.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "output_text": {
          "description": "The tool output (multiline), plus any additional info added by CSIT code.",
          "type": "string"
        },
        "reason": {
          "decription": "Just the copy the first line of the output text.",
          "type": "string"
        }
      },
      "required": [
        "output_text",
        "reason"
      ]
    },
    "iperf3_passed_object_common": {
      "description": "Sub-schema for part of iperf3 result when tool reports success, so the output is parseable into expected properties. This sub-schema does not distinguish between TCP and UDP item.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "bits_per_second": {
          "description": "The numberic part of the main performance result. Corresponding unit is obviously \"bps\".",
          "$ref": "#/$defs/positive_float"
        },
        "bytes": {
          "description": "Amount of data transferred during the test.",
          "$ref": "#/$defs/positive_integer"
        },
        "end": {
          "description": "The relative time (in seconds) of the program end.",
          "$ref": "#/$defs/positive_float"
        },
        "omitted": {
          "description": "False in well-behaved tests.",
          "type": "boolean"
        },
        "packets": {
          "description": "The number of packets transmitted by iperf3 acting as UDP client.",
          "$ref": "#/$defs/positive_integer"
        },
        "retransmits": {
          "description": "The number of packets retransmitted by iperf3 acting as TCP client. It is zero in well-behaved tests.",
          "$ref": "#/$defs/nonnegative_integer"
        },
        "seconds": {
          "description": "The relative time difference (in seconds) between program start and end.",
          "$ref": "#/$defs/positive_float"
        },
        "sender": {
          "description": "In well behaved tests, the value is true, as iperf3 is used as a client that downloads data.",
          "type": "boolean"
        },
        "start": {
          "description": "The relative time (in seconds) of the program start. In practice, this is zero (integer in json).",
          "$ref": "#/$defs/nonnegative_float"
        }
      },
      "required": [
        "bits_per_second",
        "bytes",
        "end",
        "omitted",
        "seconds",
        "sender",
        "start"
      ]
    },
    "iperf3_passed_object_tcp": {
      "description": "Sub-schema for part of iperf3 result when tool reports success, so the output is parseable into expected properties. This sub-schema matches only UDP result item.",
      "type": "object",
      "required": [
        "retransmits"
      ]
    },
    "iperf3_passed_object_udp": {
      "description": "This sub-schema matches only UDP result item.",
      "type": "object",
      "required": [
        "packets"
      ]
    },
    "iperf3_passed_object": {
      "description": "Sub-schema for part of iperf3 result when tool reports success, so the output is parseable into expected properties. This sub-schema requires either TCP or UDP result item.",
      "allOf": [
        {
          "$ref": "#/$defs/iperf3_passed_object_common"
        },
        {
          "oneOf": [
            {
              "$ref": "#/$defs/iperf3_passed_object_tcp"
            },
            {
              "$ref": "#/$defs/iperf3_passed_object_udp"
            }
          ]
        }
      ]
    },
    "hoststack_iperf3_result": {
      "description": "Sub-schema for iperf3 hoststack result, may be passed or failed. Used for hostsack tests, except VSAP or QUIC.",
      "type": "object",
      "allOf": [
        {
          "description": "The common scructure, regardless of success.",
          "additionalProperties": false,
          "properties": {
            "type": {
              "const": "hoststack_iperf3"
            },
            "object": {
              "description": "Result item, parsed as possible for given success flag.",
              "type": "object"
            },
            "success": {
              "description": "If true, numeric values are available. If false, only text output is available. This is different from test status, e.g. test may still fail, even if result is success.",
              "type": "boolean"
            }
          },
          "required": [
            "object",
            "success"
          ]
        },
        {
          "oneOf": [
            {
              "description": "Sub-schema for successful result.",
              "properties": {
                "object": {
                  "$ref": "#/$defs/iperf3_passed_object"
                },
                "success": {
                  "const": true
                }
              }
            },
            {
              "description": "Sub-schema for unsuccessful result.",
              "properties": {
                "object": {
                  "$ref": "#/$defs/hoststack_failed_object"
                },
                "success": {
                  "const": false
                }
              }
            }
          ]
        }
      ]
    },
    "vpp_echo_passed_object": {
      "description": "Sub-schema for part of vpp_echo result when tool reports success, so the output is parseable into expected properties.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "end_evt": {
          "description": "The name of the event which stops the program timer. In the current udpquic tests, both server and client programs have the same value.",
          "const": "lastbyte"
        },
        "end_evt_missing": {
          "description": "Tells whether the end event happened at all (false) or not (true). Well behaved test have false value.",
          "type": "boolean"
        },
        "role": {
          "description": "Describing whether this result item comes from server or client program.",
          "enum": [
            "client",
            "server"
          ]
        },
        "rx_bits_per_second": {
          "description": "The aggregate speed of data received by this role over its session(s), expressed in bits per second. Can be zero in unidirectional tests.",
          "$ref": "#/$defs/nonnegative_float"
        },
        "rx_data": {
          "description": "The aggregate number of bytes received by this role over its session(s). Can be zero in unidirectional tests.",
          "$ref": "#/$defs/nonnegative_integer"
        },
        "start_evt": {
          "description": "The name of the event which starts the program timer. In the current udpquic tests, both server and client programs have the same value.",
          "const": "sconnect"
        },
        "start_evt_missing": {
          "description": "Tells whether the start event happened at all (false) or not (true). Well behaved test have false value.",
          "type": "boolean"
        },
        "time": {
          "description": "The relative time difference (in seconds) between program start and end, more specificaly between the start event and the end event.",
          "$ref": "#/$defs/positive_float"
        },
        "tx_bits_per_second": {
          "description": "The aggregate speed of data transmitted by this role over its session(s), expressed in bits per second. Can be zero in unidirectional tests.",
          "$ref": "#/$defs/nonnegative_float"
        },
        "tx_data": {
          "description": "The aggregate number of bytes transmitted by this role over its session(s). Can be zero in unidirectional tests.",
          "$ref": "#/$defs/nonnegative_integer"
        }
      },
      "required": [
        "end_evt",
        "end_evt_missing",
        "role",
        "rx_bits_per_second",
        "rx_data",
        "start_evt",
        "start_evt_missing",
        "time",
        "tx_bits_per_second",
        "tx_data"
      ]
    },
    "hoststack_vpp_echo_item": {
      "description": "Sub-schema for vpp_echo hoststack result item, for one program.",
      "type": "object",
      "allOf": [
        {
          "description": "The common scructure, regardless of success.",
          "additionalProperties": false,
          "properties": {
            "object": {
              "description": "Result item, parsed as possible for given success flag.",
              "type": "object"
            },
            "success": {
              "description": "If true, numeric values are available. If false, only text output is available. This is different from test status, e.g. test may still fail, even if result is success.",
              "type": "boolean"
            }
          },
          "required": [
            "object",
            "success"
          ]
        },
        {
          "oneOf": [
            {
              "description": "Sub-schema for successful result.",
              "properties": {
                "object": {
                  "$ref": "#/$defs/vpp_echo_passed_object"
                },
                "success": {
                  "const": true
                }
              }
            },
            {
              "description": "Sub-schema for unsuccessful result.",
              "properties": {
                "object": {
                  "$ref": "#/$defs/hoststack_failed_object"
                },
                "success": {
                  "const": false
                }
              }
            }
          ]
        }
      ]
    },
    "hoststack_vpp_echo_result": {
      "description": "Sub-schema for vpp_echo hoststack result, for all programs.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "hoststack_vpp_echo"
        },
        "outputs": {
          "description": "Result items, parsed as possible for given success flag. The current tests use exactly two programs (client and server).",
          "type": "array",
          "minItems": 2,
          "maxItems": 2,
          "items": {
            "$ref": "#/$defs/hoststack_vpp_echo_item"
          }
        }
      },
      "required": [
        "objects"
      ]
    }
  }
}