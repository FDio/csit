
Dicussion on CSIT oper branches
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TL;DR
~~~~~

CSIT oper branch is maintained so that VPP verify and trending jobs
do not attempt to follow rapidly moving CSIT target.

I argue CSIT target is no longer moving that rapidly, and "batching"
CSIT changes to come once a week does not give enough stability benefits,
compared to CSIT developer overhead and delayed CSIT features.

Continuous delivery
~~~~~~~~~~~~~~~~~~~

VPP and CSIT use separate git repositories, while important deliverables
(such as trending results) need both codebases to work together.

The coupling between CSIT and VPP is quite tight,
and only some interfaces are documented and stable enough.

There is a great number of performance tests, it is not feasible
to run all tests for each VPP or CSIT merge.

Tiered testing
..............

A solution to the continuous delivery problem is tiered testing.

When not every merge can be comprehensively tested, there should be
"tiers" of test coverage (from fast but shallow to deep but slow).

Every merge can be tested with shalow tests, but only some merges
get time for deeper testing.

With two independently moving (but still coupled) components (VPP and CSIT),
shallow tests for CSIT merges should use deeply tested VPP builds,
and shallow tests for VPP merges should use deeply tested CSIT code.

When a deliverable wants to use a very recent (thus only shallowly tested)
builds of VPP, it should use deeply tested CSIT code.

How deeply tested? There is a trade-off between "stable enough"
and "recent enough". If deeply tested CSIT code contains long-standing bugs
and lacks recent improvements, we may decide to use less deeply tested CSIT code.

History
~~~~~~~

Functional tests
................

From the very early days, there have been functional test in CSIT,
that got executed on every CSIT patch. The initial implementation was using
VIRL system to create test topology using VMs.

The initial focus was to verify basic functionality of VPP.
Over the time, most of basic functionality testing become covered
by "make test" run in VPP verify jobs, so failure in functional jobs
was either due to wrong assumptions (or bugs and typos) in CSIT code,
or it was caused by a functionality not suitably testable in "make test",
such as testing with real NICs and drivers.

In CSIT, we introduced device tests, as a way to run more verify
jobs in parallel while using hardware NICs (at least their virtual functions).
The selection of tests run in devicetest jobs was focused on testing
NIC drivers (and associated input graph nodes), later expanded also to
increase coverage of binary API messages used by CSIT.
The number of selected tests was otherwise kept small,
so the runs do not take long to finish.
When device tests become stable enough, VIRL jobs were deleted, and even later
the device test results were stable enough to become voting in VPP.

Around that time, VPP introduced API stability process,
which prevents "production" VPP API messages from changing their argument
(structure, field names, types).
Other ways to configure VPP (CLI, VAT) do not enjoy this level of stability.

Before CRC checks and device tests became voting in VPP,
there was no automated way to gate VPP changes that can break CSIT tests.
With the two in place, such breakages are rare.

Performance tests
.................

From the very early days, there were periodic (weekly or daily) performance jobs
testing the most recent VPP version. Performance tests take longer to finish
(compared to functional tests), there is a larger number of them,
and they require access to physical testbeds, of which we have multiple types
but small number of copies per type.

That means not even CSIT changes have automated verify job with
performance tests. There is a manual trigger available, but that relies on
CSIT committers knowing which performance tests are likely to be broken
by a CSIT patch under review, so there is always a risk of unintended breakages.

Stable and oper
---------------

Tiered testing got implemented in two ways.
For VPP builds, CSIT code started tracking "Stable VPP Version",
that was to be used when testing new CSIT changes.
For CSIT commits, we created "oper" branches, to be used to test new VPP builds.

Both ways to mark privileged code is in hands of CSIT committers,
as they usually track test failures more closely.
As fixes in CSIT tend to be smaller and delivered faster,
it is common to cherry-pick any such fix from CSIT master (or release)
to its current oper branch. New CSIT oper branch is created each week,
as it is easier to fork from master than to cherry-pick the other
not-fix CSIT changes.
VPP stable version is also updated once a week, unless something
(critical fix, API change) is worth attention.

TODO: When was the last time CSIT rolled back by deleting oper branch?

Surprises
~~~~~~~~~

Most of the time a job or a test fails because it detects an error
in VPP or CSIT code (and passes otherwise).
If that is not true, it is called a surprise.
Here are few known surprise types.

Infra surprise
..............

Failure to checkout the required git commit, ClosedChannelException,
Device creation fails...
The symptoms can be numerous, but quite distinctive.

Sometimes re-checking helps. Other times jobs are blocked until the infra issue
is identified and fixed.

Merge surprise
..............

In the current Gerrit submit mode
(automatic rebase when Submit button is pressed)
there is a possibility of an error that is not detectable by current verify jobs.
Imagine there are two changes waiting for review, A and B.
The change A adds a new functionality using existing functions.
The change B refactors and renames some of the functions.
Both changes pass review, both are merged concurrently
and Gerrit does not complain about merge conflicts.
But the final code does not work, as the new functionality from change A
expects function names that are no longer present since change B.

Currently, this kind of error may happen, both in CSIT and in VPP.
The error can be fixed by reverting B, but that may take a while
if unaware committers keep merging subsequent changes (based on A or earlier).

Anyway, this surprise is usually easily detected (changes based on new HEAD
start failing verify jobs with a common symptom unrelated to the change),
and does not need a specific verify job. Still, it can cause
different behavior in otherwise identically behaving jobs.

Properties of jobs
~~~~~~~~~~~~~~~~~~

We have many types of jobs, here is a table:

+------------------------------+--------+--------+---------+
| jobs                         | CSIT   | VPP    | trigger |
+------------------------------+--------+--------+---------+
| csit-dpdk-perf-report-*      | gerrit | no     | manual  |
| csit-dpdk-perf-verify-*      | gerrit | no     | manual  |
| csit-trex-perf-verify-*      | gerrit | no     | manual  |
| csit-verify-tox-*            | gerrit | no     | vote    |
| csit-vpp-device-*            | gerrit | stable | vote    |
| csit-vpp-perf-report-*       | gerrit | stable | manual  |
| csit-vpp-perf-verify-*       | gerrit | stable | manual  |
| csit-report-merge-*          | head   | no     | manual  |
| csit-docs-merge-*            | head   | no     | timed   |
| csit-trending-merge-*        | head   | no     | timed   |
| csit-vpp-device-*-weekly     | head   | stable | timed   |
| csit-vpp-device-*-semiweekly | oper   | latest | timed   |
| csit-vpp-perf-mrr-*          | oper   | latest | timed   |
| csit-vpp-perf-ndrpdr-*       | oper   | latest | timed   |
| csit-dpdk-perf-mrr-*         | oper   | no     | timed   |
| vpp-csit-verify-api-crc-*    | oper   | gerrit | vote    |
| vpp-csit-verify-device-*     | oper   | gerrit | vote    |
| vpp-csit-verify-perf-*       | oper   | gerrit | manual  |
+------------------------------+--------+--------+---------+

Legend:
+ CSIT values describe CSIT codebase used.
 + Gerrit means CSIT code that is not merged yet.
 + Head means HEAD of the corresponding (master or release) branch.
 + Oper means HEAD of latest oper branch corresponding to master or release.
+ VPP values describe VPP codebase used.
 + No means this job does not interact with VPP code in any way.
 + Gerrit means unmerged code (has to be build in the job).
 + Latest means the latest VPP build for the branch available in Packagecloud.
 + Stable means the build marked as STABLE in CSIT code used.
+ Trigger values describe how the job is started.
 + Manual means it has to be triggered by human (e.g. via a Gerrit comment).
 + Timed means it starts periodically (daily, weekly, ...).
 + Vote means it starts whenever there is a new Gerrit patch uploaded
   (or re-checked). Not all jobs of this type do vote (e.g. ARM device jobs).

Current relations
~~~~~~~~~~~~~~~~~

When there are no surprises, there are following relations between jobs.

csit-vpp-device-*-semiweekly tests the same code combination previously tested by
vpp-csit-verify-device-* job (unless VPP merge surprise happens).
As the latter is voting, the former can only fail on some surprise.

csit-vpp-device-*-weekly tests the same code combination previously tested by
csit-vpp-device-* job (unless CSIT merge surprise happens).
As the latter is voting, the former can only fail on some surprise.

csit-vpp-perf-mrr-* and csit-vpp-perf-ndrpdr-* jobs can still fail,
even though the same combination is tested by vpp-csit-verify-perf-*,
because the latter is manually triggered, and the former take too long
(so it is not feasible to run that many tests on each VPP patch).
There is some overlap in coverage of the former and vpp-csit-verify-device-*
(and vpp-csit-verify-api-crc-*), which prevents some failures, but not all.

It may be possible to create a selection of performance tests
to catch some expected breakages, but experience shows "expected breakages"
are not that more probable than "unexpected breakages".

Oper pros and cons
^^^^^^^^^^^^^^^^^^

Oper pros
.........

If a breakage / regression happens just after creation of new oper branch,
the cause was probably CSIT.

Big rollback can be done simply by deleting latest oper branch.

Priority fixes can still be cherry-picked into oper branch.

Oper cons
.........

Cherry-picks to oper branch do not have even tox verification.

Cherry-picks to oper branch do not have devicetest verification.

Thus CSIT merge surprise is more likely than usual (as the maste verify job
was testing different CSIT codebase), but still not very likely.

Currently no perf verification when creating new oper branch.

No perf verification for cherry-picks either.

Oper branch creation, deletion and cherry-picks is an overhead
for CSIT developers.

Stable VPP version
..................

Compared to oper branch, Stable VPP version has more pros and less cons:

Lesser overhead, as no cherry-picks are possible.

Stable version can be chosen based on weekly jobs, so it is tested deeply enough.

No important automatic deliverable needs bleeding edge CSIT,
and manual deliverables can tweak the stable version,
or even use vpp-csit-verify-perf-* to test with unmerged VPP code.

Unsorted remarks
~~~~~~~~~~~~~~~~

There are currently no jobs that would test latest VPP with latest CSIT
(it is possible to use vpp-csit-verify-perf-* to get this combination
on demand, if the human triggering it has committer rights).

Oper branches are removed from Gerrit periodically, to avoid spam.
This makes it hard to investigate older results from periodic jobs,
as it is harder to find what was in the CSIT commit used.
The github mirror does not remove the old oper branches,
so the old commits can be found there, but also the "branches" list is big.

Since we had CRC checking job and voting devicetest jobs
on both VPP and CSIT side, breakages in performance results are less frequent,
as big refactors are less frequent, and CSIT committers have more experience
in selecting which perf tests to run to verify nothing important get broken.

Proposals
~~~~~~~~~

Remove
......

Stop creating oper branches, switch all jobs currently using oper branch
to use HEAD (also for older release branches).

We keep a small script to select CSIT master branch when CSIT release branch
is not created yet (from vpp-csit job when new VPP stable branch is created).
This fallback functionality is currently handled by with_oper_for_vpp.sh script.

In future, we may also remove Stable VPP version marker,
but there is less risk and overhead in that, so lower priority.

Verify
......

Add jobs that run a seletion of perf tests for stable VPP and HEAD CSIT, weekly.

At least two jobs are needed (one 2-node, one 3-node). Not too many jobs,
as there is a possibility of CSIT merge happening between two jobs start,
and we only want a single weekly commit to get tested.

Alternative: Start such jobs manually, thus guaranteeing the CSIT commit
used is the same for all jobs.

Only create new oper branch if the new results are not worse than old results.

When a cherry-pick is needed, merge it quickly, but also start the two
perf jobs to verify the impact on other tests.
Maybe add the test that required the cherry-pick (if it was a fix).
Periodically revisit the selection of tests to keep runtime low
while coverage remains high.

TODOs
~~~~~

Convert to .rst or .md so the table and its structured legend render correctly.
