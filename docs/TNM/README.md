# The New Model

Version 0.1.0

#### Content

- [Changelog](#changelog)
- [TODOs](#todos)
- [Note](#note)
- [Overview](#overview)


- [The Model](#the-model)
  - [Components](#components)
    - [SUT Specification](#sut-specification)
    - [Processing Module](#processing-module)
    - [Suite and Test](#suite-and-test)
    - [Test data](#test-data)
    - [PAL](#pal)
    - [PAL Specification](#pal-specification)
    - [Presentation](#presentation)
  - [Procedure](#procedure)


- [Specification of the topology](#specification-of-the-topology)
  - [Structure](#structure)
  - [Topology](#topology)
    - [Network](#network)
    - [Node](#node)
    - [Link](#link)


- [Unified Test Interface](#unified-test-interface)
  - [Data structure](#data-structure)
    - [Top Level Sections](#top-level-sections)
    - [Metadata](#metadata)
    - [Results](#results)
  - [Chain of Changes](#chain-of-changes)
  - [Unified Test Interface Lifecycle](#unified-test-interface-lifecycle)
    - [Initialisation](#initialisation)
    - [Data Collection](#data-collection)
    - [Providing the Collected Data](#providing-the-collected-data)


- [Implementation](#implementation)
  - [Design](#design)
  - [Tools and Libraries](#tools-and-libraries)

#### Changelog

| Version  | Changes                                                          |
|----------|------------------------------------------------------------------|
| 0.1.0    | Initial revision                                                 |

#### TODOs

1. Add implementation details here: [Implementation](#implementation)

#### Note

The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119
"Key Words for use in RFCs to Indicate Requirement Levels").

#### Overview

This document describes the new model of configuring and running tests / suites
and collecting the operational data and results produced by them.
The first chapter [The Model](#the-model) briefly describes the model itself.
Then it deals with
[Specification of the topology](#specification-of-the-topology) as a JSON
structure which is a full and the only description of the SUT and its
implementation as a directed graphs with self loops and parallel edges;
and the [Unified Test Interface](#unified-test-interface) which is the only
configuration (if used as an input), and the only output of a test (results,
operational data, counters).

# The Model

![The new architecture](pics/overview.svg "The new architecture")

## Components

Components stored in the repository:
- [SUT Specification](#sut-specification)
- [PAL Specification](#pal-specification)

Components running in RAM and keeping all data in RAM during runtime:
- [Processing Module](#processing-module),
- [PAL](#pal)

Component running on a testbed by CI/CD:
- [Suite and Test](#suite-and-test)

Components stored in a data storage:
- [Test data](#test-data),
- [Presentation](#presentation)

### SUT Specification

SUT specification is a JSON file
([example](topology_model.json "topology_model.json")) containing the full
information about the system under test. It includes mainly:

- topology
- configuration of all nodes and links (start-up and run-time configuration)

For more information see the section
[Specification of the topology](#specification-of-the-topology).

### Processing Module

When a test starts, an instance of the processing module is created. It reads
the SUT specification and creates a model of the tested network topology.
Then it passes the configuration information to the test.

While the test runs, it continuously collects operational data and passes it
to the processing module together with the results. All collected information
is preserved even the test fails in a fatal way.

At the end, the data is transformed to JSON format and sent to the storage
by CI/CD tool.

### Suite and Test

> TODO: Decide if it will operate on a suite or test level.

Test running on a test bed configured by the processing module with data from
SUT Specification and providing all operational data and results back to the
processing module.

### Test data

All information about a test (topology, test bed configuration, DUT
configuration, operational data, results, ...) stored in a database.

### PAL

Presentation and Analytics Layer (PAL) makes possible to present and
analyse the test results generated by CSIT Jenkins jobs.

### PAL Specification

PAL specification is a YAML file
([example](../../resources/tools/presentation/specification.yaml)) which
specifies all elements to generate by PAL.

It is not necessary to modify the current version, but there is a place for
optimization.

### Presentation

The presentation includes all elements generated by PAL and published.

## Procedure

1. Create the instance of "Test Data Processing".
1. Read the specification of the suite / test.
1. Configure the suite / test.
1. Run the suite / test.
1. Collect data while running the test. If running a suite, collect data
   separately for each test.
1. Collect the results from the test. If running a suite, collect results
   separately for each test.
1. Save suite / test data locally. Save all collected data and results even
   the test / suite / build fails.
1. Upload all data to the storage.

# Specification of the topology

See an example SUT specification [here](topology_model.json).

## Structure

The topology specification is a JSON file which includes the information
about the network, its nodes and links. It specifies its setup and
configuration and collects its states and operational data.

## Topology

The topology is described as a network by nodes with termination points and
links between them. Each element in this model has attributes, some of them
have configuration data. See below.

```json
{
  "version": "0.1.0",
  "metadata": {},
  "reference": {},
  "network": {
    "network-id": "str",
    "node": [],
    "link": []
  }
}
```

**version**

Version of the specification. Versioned is the structure of the specification
not data in it. This key MUST be present in the specification and its name
MUST NOT be changed. Its value MUST be changed after each update of the
structure. It consists of three parts separated by a dot: MAJOR.MINOR.PATCH.
Increment the:
  - MAJOR version when the changes are incompatible with the previous version,
  - MINOR version when the changes are backwards compatible with the previous
    version, and
  - PATCH version when the changes are backwards compatible bug fixes.

The version of the data specification, and the version of this document MUST be
the same.

**metadata**

Key-value pairs defining the metadata of the model.

**reference**: 

```json
{
  "reference": {
    "ref_1_ID": {},
    "ref_2_ID": {},
    "ref_N_ID": {}
  }
}
```

Dictionaries specified in this section CAN be used anywhere in the model.
In that case, the reference is replaced by a dictionary with corresponding
reference ID from this section. After replacement, another key-value pairs
CAN be added, or the existing CAN be changed. It can be useful, e.g. when
is are more than one very similar nodes in the topology.

**network**: The network itself, see the description below.

### Network

```json
{
  "network": {
    "network-id": "str",
    "attr": {},
    "node": [],
    "link": []
  }
}
```

A network is defined by [nodes](#node) with termination points connected by
[links](#link).

**network-id**

Unique ID identifying the network. This example includes only one network,
but, in general, there can be more than one network in the model.

**attr**

Key-value pairs defining the attributes of the network.

**node**

List of nodes in the network, see [Node](#node).

**link**

List of links connecting the nodes, see [Link](#link).

### Node

A node in the network CAN be software providing a network function (e.g. VPP)
or a container, VM, etc.

```json
{
  "network": {

    "node": [
      {
        "node-id": "str",
        "parent": "str node-id",
        "children": "list of node-ids",
        "attr": {},
        "configuration": {
          "start-up": {},
          "run-time": "dictionary or list of dictionaries",
          "traffic-profile": "str path to file",
          "traffic-specification": "str path to file or JSON"
        },
        "state": [],
        "command-history": [],
        "termination-point": []
      }
    ]

  }
}
```

**node-id**

Unique ID identifying a node in the network.

**attr**

Key-value pairs defining the attributes of the node, e.g. type of node.

**configuration**

Configuration of the node. The structure of this item depends on the type of
node which is specified in the attributes. The structure of the configuration
MUST be JSON compatible.

- *start-up* - the configuration used before DUT starts
- *run-time* - the configuration used to configure the DUT while it
  runs, e.g. to configure it for the specific test. If the DUT is reconfigured
  during its run-time, this item is a list with configurations in the correct
  order.
- *traffic-profile* - the path to the traffic profile used for the test. Traffic
  profile depends on the TG used.
- *traffic-specification* - JSON data structure fully describing all parameters
  of the traffic used for the test.

> **Note:** The items `traffic-profile` and `traffic-specification` are covered
> in a separate document.
> 
> **TODO:** Add a link to the document.

**state**

This item lists states of the node in the chronological order. There also MUST
be a timestamp to make possible to reconstruct the state of the whole network.

```json
{

        "state": [
          {
            "state-id": "str",
            "timestamp": "datetime",
            "operational-data": {}
          },
          {}
        ]

}
```

Each type of node has its own set of states, and each state of node CAN have
its own operational data. The structure of operational data depends on the node
and its current state. The structure of the operational data MUST be JSON
compatible.

**command-history**

Some nodes CAN be configured by a set of commands during the test. This item
lists them in the chronological order. There also MUST be a timestamp to make
possible to reconstruct the command flow in the context of the whole network.

```json
{

        "command-history": [
          {
            "timestamp": "datetime",
            "command": "str",
            "return-code": "int",
            "response": "str"
          },
          {}
        ]

}
```

> **TODO:** Data type of "command" and "response" : str or JSON?

**termination-point**

A termination point is a point belonging to a node which makes possible to
connect nodes by links.

```json
{

        "termination-point": [
          {
            "tp-id": "str",
            "attr": {}
          },
          {}
        ]

}
```

Each termination point MUST have a unique ID and CAN have a set of attributes.

### Nested nodes

A node can include zero, one, or more nested nodes. The node with nested
node(s) is the parent, a node nested in another node is its child.

```json
{
  "network": {

    "node": [
      {
        "node-id": "str",
        "parent": "str node-id",
        "children": "list of node-ids",
        "attr": {},
        "configuration": {},
        "state": [],
        "command-history": [],
        "termination-point": []
      }
    ]

  }
}
```

**parent**

`node-id` of the parent node. There can be only one parent for the
node. If the `parent` is not defined (this key does not exist), the node is not
a nested node.

**children**

List of children of the node. It includes the `node-id` of all nodes nested in
this node. If the `children` is empty, or it is not defined (this key does not
exist), the node has no nested nodes.

### Link

Nodes are connected to each other by links which begin and end in termination
points.

```json
{
  "network": {
    
    "link": [
      {
        "link-id": "str",
        "attr": {},
        "source": {
          "source-node": "node-id",
          "source-tp": "tp-id"
        },
        "destination": {
          "destination-node": "node-id",
          "destination-tp": "tp-id"
        }
      },
      {}
    ]

  }
}
```

**link-id**

Unique ID identifying a link in the network.

**attr**

Key-value pairs defining the attributes of the link, e.g. type of the link
(unidirectional, bidirectional).

**source**

The node and the termination point where the link begins. It is also the source
of the traffic.

**destination**

The node and the termination point where the link ends. It is also the consumer
of the traffic.

# Unified Test Interface

The described JSON data structure is a single source of output data from a
test. The data included in it is collected during the setup and testing phases
of each test. At the end a dedicated RF keyword prints created JSON structure
as a human-readable string into the output.xml file, level info. It is not
necessary to print it as the test message. The information can be then parsed
out processed by PAL.

## Data Structure

### Top Level Sections

For detailed information see the [example](unified_test_interface.json).

```json
{
  "version": "0.1.0",
  "metadata": {},
  "reference": {
    "ref_1_ID": {},
    "ref_2_ID": {},
    "ref_N_ID": {}
  },
  "network": {
    "network-id": "str",
    "attr": {},
    "node": [],
    "link": []
  },
  "test": {
    "metadata": {},
    "results": {}
  }
}
```

The items
- version,
- metadata,
- reference,
- network

are the same and with the same structure as defined in
[Specification of the topology](#specification-of-the-topology). 

The items
- network --> node --> state,
- network --> node --> command-history

are filled with data during the runtime of the test.

There is a new item `test` which includes all information about the test:
- **metadata** - This key SHOULD be present in the structure and its name
  SHOULD NOT be changed. If there are any changes in this section, the
  `data_structure_version` MUST be increased.
- **results** - This key SHOULD be present in the structure and its name SHOULD
  NOT be changed. If there are any changes in this section, the
  `data_structure_version` MUST be increased.

### Metadata

This section includes data about:

- **test_executor** - The name of executor (e.g. Jenkins) and its base
  parameters e.g. job name and build number.
- **test_execution** - Parameters of test execution itself, e.g. status.
- **test** - Test parameters, e.g. test ID, tags, documentation, ...

```json
{

    "metadata": {
      "test_executor": {
        "ci": "str [jenkins | s5ci | manual]",
        "job": "str",
        "build": "int"
      },
      "test_execution": {
        "start_time": "str datetime",
        "end_time": "str datetime",
        "status": "str [PASS | FAIL]"
      },
      "test": {
        "id": "str fullname",
        "type": "str [NDRPDR | MRR | SOAK | ...]",
        "tags": "list [str]",
        "documentation": "str",
        "test-history": {
          "hash": "str hash",
          "previous_hash": "str previous hash"
        }
      }
    }

}
```

**test_executor**

This item identifies the test executor, its properties and parameters.

**test_execution**

Information about the test execution itself (start and end timestamp, status,
...).

**test**

The parameters of the test.

### Results

Results of the test. Their structure and items present in it depend on the test
type.

```json
{

    "results": {
      "total": {
        "forward": {
          "throughput": {},
          "latency": {},
          "mrr": {},
          "soak": {},
          "another_item": {}
        },
        "reverse": {},
        "total": {}
      },
      "node": [
        {
          "node-id": "str",
          "termination-point": [
            {
              "tp-id": "str",
              "rx-counters": {},
              "tx-counters": {}
            },
            {}
          ]
        },
        {}
      ]
    }

}
```

> TODO: Describe the structure of results of currently existing tests.

## Chain of Changes

TODO







## Unified Test Interface Lifecycle

TODO

### Initialisation

TODO

### Data collection

TODO

### Providing the collected data

TODO







# Implementation

TODO

## Design

TODO

## Tools and Libraries

TODO

[NetworkX](https://networkx.org/documentation/stable/index.html
"NetworkX - Network Analysis in Python")



