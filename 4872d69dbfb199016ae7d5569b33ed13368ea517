{
  "comments": [
    {
      "key": {
        "uuid": "5a05d7a2_583c5bef",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 258,
      "author": {
        "id": 76
      },
      "writtenOn": "2019-05-29T06:15:01Z",
      "side": 1,
      "message": "any reason not to use FOR loop? which is much simpler",
      "range": {
        "startLine": 258,
        "startChar": 8,
        "endLine": 258,
        "endChar": 27
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8c8a6733_aa39f30a",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 258,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-05-29T08:25:46Z",
      "side": 1,
      "message": "Is it because with FOR loop you can only easily define number of retries, which can take longer than timeout if the checks themselves take some (unpredictable) time.\n\nSo I agree with while and time checking. The rest of the code is complicated, because of the need to report all not_ready interfaces.",
      "parentUuid": "5a05d7a2_583c5bef",
      "range": {
        "startLine": 258,
        "startChar": 8,
        "endLine": 258,
        "endChar": 27
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "65f4ee9a_b34fb386",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 258,
      "author": {
        "id": 76
      },
      "writtenOn": "2019-05-29T08:56:13Z",
      "side": 1,
      "message": "And that is wrong. Example: API call takes 10s\n\nIF timeout is 30 I can (roughly) check VPP 2 times for VPP it it means it must be ready under 20s! because last read happen in t\u003d20 (so only 2 API call to check)\n\nIF nr retries is 30 I can poll vpp 30 times (here we can tune how many times to find balance time vs retries. But i have greater chance to catch VPP is ready after 30s.\n\nThe problem FOR loop is solving is longevity of API call. So it is dormant for how long the reply takes (because of NW fluctuation, process busy or so).",
      "parentUuid": "8c8a6733_aa39f30a",
      "range": {
        "startLine": 258,
        "startChar": 8,
        "endLine": 258,
        "endChar": 27
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "583712bf_a1bbaa3f",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 258,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-05-29T12:00:16Z",
      "side": 1,
      "message": "\u003e And that is wrong.\n\u003e last read happen in t\u003d20\n\nIt is not wrong. At second read, line 261 sets now (to ~20s), so even when the condition on line 268 is evaluated at time~30, is will still allow the third read.\n\n\u003e So it is dormant for how long the reply takes\n\nIf we have busy process, or other issue deaying the test execution, I say we still fail because we need to fix something. The timeout should correspond to what are we willing to tolerate (but not more). Also, the fact that read is slow might mean something is wrong on CSIT side, and VPP had plenty time to become ready.\n\nIdeal logic would set both maximal timeout and maximal number of reads and fail whichever is reached first.",
      "parentUuid": "65f4ee9a_b34fb386",
      "range": {
        "startLine": 258,
        "startChar": 8,
        "endLine": 258,
        "endChar": 27
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e18afa1_b71af807",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 258,
      "author": {
        "id": 207
      },
      "writtenOn": "2019-05-29T12:12:36Z",
      "side": 1,
      "message": "OK, will convert it to number of tries fir for loop.",
      "parentUuid": "65f4ee9a_b34fb386",
      "range": {
        "startLine": 258,
        "startChar": 8,
        "endLine": 258,
        "endChar": 27
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8be08d96_83c9d9d7",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 258,
      "author": {
        "id": 76
      },
      "writtenOn": "2019-05-29T12:17:03Z",
      "side": 1,
      "message": "\u003e It is not wrong. At second read, line 261 sets now (to ~20s), so even when the condition on line 268 is evaluated at \u003e time~30, is will still allow the third read.\n\nSo the total timeout is not guaranteed anyway as it might take 40s in fact.\n\n\u003e The timeout should correspond to what are we willing to tolerate (but not more). \n\nI think the base problem is just if we need fixed amount of retries (with intergap) or we want total time (non of them are safe in terms of how long it will execute), but doing retry can be more safe in way that it will try more times before quit. In this case we would see how interfaces are becoming UP with increased retry. With total time and API duration 30s we are lost anyway. If API takes 1s it is pointless to distinguish, but if API takes longer we must made decision.\nIn fact most of the KW i think are now doing something like 600s just because VPP is becoming slower. So which one is better for slow APIs. \n\nIn Linux libraries we use nr_of_retry as main criteria.",
      "parentUuid": "583712bf_a1bbaa3f",
      "range": {
        "startLine": 258,
        "startChar": 8,
        "endLine": 258,
        "endChar": 27
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f0868dac_c165e186",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 258,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-05-29T12:44:09Z",
      "side": 1,
      "message": "\u003e So the total timeout is not guaranteed anyway as it might take 40s in fact.\n\nStill far better than with setting number of retries.\n\n\u003e but doing retry can be more safe in way that it will try more times before quit.\n\nOnce again, preventing horrible runtimes is more important to me than allowing overloaded VPP enough time to react.\n\n\u003e Ideal logic would set both maximal timeout and maximal number of reads and fail whichever is reached first.\n\nStill appears to be ideal for both of us (except having more complicated code).",
      "parentUuid": "8be08d96_83c9d9d7",
      "range": {
        "startLine": 258,
        "startChar": 8,
        "endLine": 258,
        "endChar": 27
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51b28fd2_6a3e39de",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 267,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-05-29T08:25:46Z",
      "side": 1,
      "message": "break\n\nThat way you do not need line 256.",
      "range": {
        "startLine": 267,
        "startChar": 16,
        "endLine": 267,
        "endChar": 31
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f1440644_9ce16a8a",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 303,
      "author": {
        "id": 76
      },
      "writtenOn": "2019-05-29T06:15:01Z",
      "side": 1,
      "message": "remove one of those. i do not see a reason to have it twice",
      "range": {
        "startLine": 276,
        "startChar": 0,
        "endLine": 303,
        "endChar": 75
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d80038c2_e244edb8",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 303,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-05-29T08:25:46Z",
      "side": 1,
      "message": "The first one, as I do not see the point of checking TG interfaces. Actually, InterfaceUtil.vpp_get_interface_data(node) should probably fail with TG node.",
      "parentUuid": "f1440644_9ce16a8a",
      "range": {
        "startLine": 276,
        "startChar": 0,
        "endLine": 303,
        "endChar": 75
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f79fad1a_146ee1fc",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 303,
      "author": {
        "id": 207
      },
      "writtenOn": "2019-05-29T12:12:36Z",
      "side": 1,
      "message": "Agree, we will keep all_vpp_interfaces_ready_wait method.",
      "parentUuid": "d80038c2_e244edb8",
      "range": {
        "startLine": 276,
        "startChar": 0,
        "endLine": 303,
        "endChar": 75
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ef1a4c78_5923a7bc",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 1794,
      "author": {
        "id": 76
      },
      "writtenOn": "2019-05-29T06:15:01Z",
      "side": 1,
      "message": "is this new line breaking gerrit review syntax analysis? (the rest of code is not parsed)",
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d523ced3_423ff44d",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 1794,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-05-29T08:25:46Z",
      "side": 1,
      "message": "\u003e the rest of code is not parsed\n\nIt shows parsed for me.",
      "parentUuid": "ef1a4c78_5923a7bc",
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ec1f2a92_ba5ea582",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 1879,
      "author": {
        "id": 76
      },
      "writtenOn": "2019-05-29T06:15:01Z",
      "side": 1,
      "message": "Memif, vhost, vxlan, vlan, ... should we have dedicated single function for adding them to topology representation?",
      "range": {
        "startLine": 1878,
        "startChar": 0,
        "endLine": 1879,
        "endChar": 30
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f95f4ede_4b4ffd30",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 1879,
      "author": {
        "id": 207
      },
      "writtenOn": "2019-05-29T12:12:36Z",
      "side": 1,
      "message": "These three methods (vpp_create_vxlan_and_vlan_interfaces, vpp_put_vxlan_and_vlan_interfaces_up, vpp_put_vxlan_and_vlan_interfaces_to_bridge_domain) where creted to fix pylinth complaints about too many local variables in method vpp_create_multiple_vxlan_ipv4_tunnels. They follows also required sequence of initialization multiple (e.g. 1000) vxlan tunnels for performance tests:\n\n1. configure ip addresses, create vxlan and vlan interfaces\n2. put interfaces up + add them to topo\n3. configure bridge domains and ip routes\n\nThey are used only in vxlan scale performance tests where we need to configure all required tunnels in one PAPI call as it was done in case of VAT call (you remember, in standard way of VAT call per every command it took hours to do this configuration so it was switched to write vat commands to file and read and execute these vat commands in one VAT call).",
      "parentUuid": "ec1f2a92_ba5ea582",
      "range": {
        "startLine": 1878,
        "startChar": 0,
        "endLine": 1879,
        "endChar": 30
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "86d0ab01_f98611b4",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 1982,
      "author": {
        "id": 76
      },
      "writtenOn": "2019-05-29T06:15:01Z",
      "side": 1,
      "message": "same as below",
      "range": {
        "startLine": 1979,
        "startChar": 0,
        "endLine": 1982,
        "endChar": 38
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0870ee8a_ff0006ce",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 1993,
      "author": {
        "id": 76
      },
      "writtenOn": "2019-05-29T06:15:01Z",
      "side": 1,
      "message": "Any reason not to use function for ip_add_del_route here? If we would have ip_add_del_route function here is copy so if API changes someone needs to look on this as well. \nI know this is nice shortcut function but i think we should split. \n\n(once the ipv4 module will be ready)",
      "range": {
        "startLine": 1983,
        "startChar": 0,
        "endLine": 1993,
        "endChar": 69
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7edafe5e_39a3c577",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 1993,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-05-29T08:25:46Z",
      "side": 1,
      "message": "Add a TODO?",
      "parentUuid": "0870ee8a_ff0006ce",
      "range": {
        "startLine": 1983,
        "startChar": 0,
        "endLine": 1993,
        "endChar": 69
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "951d8b07_13a62f84",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 1993,
      "author": {
        "id": 207
      },
      "writtenOn": "2019-05-29T12:12:36Z",
      "side": 1,
      "message": "See comment on line 1879 - we need to use bulk of PAPI commands in one PAPI call otherwise the whole configuration can take an hours. Maybe it can be changed when PAPI will use remote socket and we well be able to run thousands of PAPI commands separately without need to do an ssh connection per PAPI call.",
      "parentUuid": "7edafe5e_39a3c577",
      "range": {
        "startLine": 1983,
        "startChar": 0,
        "endLine": 1993,
        "endChar": 69
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f8c235bc_647fddd2",
        "filename": "resources/libraries/python/InterfaceUtil.py",
        "patchSetId": 64
      },
      "lineNbr": 1993,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-05-29T12:26:27Z",
      "side": 1,
      "message": "\u003e use function for ip_add_del_route here?\n\u003e without need to do an ssh connection per PAPI call\n\nCurrent implementation of socket executor cannot sustain two connections at once.\n\nBetter solution would be to introduce internal function add_cmd_add_del_route, so that both ip_add_del_route and bulk additions in other keywords would call that (and call get_replies later when everything is prepared).\nThat assumes that calling the new add_cmd_add_del_route function would take less space than the current dict, otherwise any API change would make that as brittle as this.",
      "parentUuid": "951d8b07_13a62f84",
      "range": {
        "startLine": 1983,
        "startChar": 0,
        "endLine": 1993,
        "endChar": 69
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b6bbf270_4ee9c445",
        "filename": "resources/libraries/robot/ip/ip4.robot",
        "patchSetId": 64
      },
      "lineNbr": 44,
      "author": {
        "id": 76
      },
      "writtenOn": "2019-05-29T06:15:01Z",
      "side": 1,
      "message": "Be more verbose about arguments :)",
      "range": {
        "startLine": 44,
        "startChar": 0,
        "endLine": 44,
        "endChar": 75
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "af47b14a_6a11d788",
        "filename": "resources/libraries/robot/overlay/vxlan.robot",
        "patchSetId": 64
      },
      "lineNbr": 139,
      "author": {
        "id": 76
      },
      "writtenOn": "2019-05-29T06:15:01Z",
      "side": 1,
      "message": "missing params",
      "range": {
        "startLine": 139,
        "startChar": 37,
        "endLine": 139,
        "endChar": 37
      },
      "revId": "4872d69dbfb199016ae7d5569b33ed13368ea517",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    }
  ]
}