diff --git a/src/vpp-api/python/vpp_papi/vpp_papi.py b/src/vpp-api/python/vpp_papi/vpp_papi.py
index 5207bbf0b..f9e48e7c2 100644
--- a/src/vpp-api/python/vpp_papi/vpp_papi.py
+++ b/src/vpp-api/python/vpp_papi/vpp_papi.py
@@ -658,8 +658,10 @@ class VPPApiClient(object):
 
             if not multipart:
                 rl = r
+                logger.debug("Adding part {r!r}".format(r=r))
                 break
             if msgname == 'control_ping_reply':
+                logger.debug("Got ping reply {r!r}".fomrat(r=r))
                 break
 
             rl.append(r)
@@ -690,6 +692,7 @@ class VPPApiClient(object):
             kwargs['client_index'] = 0
         kwargs['_vl_msg_id'] = i
         b = msg.pack(kwargs)
+        logger.debug("Sending async {b!r}".format(b=b))
 
         self.transport.write(b)
 
diff --git a/src/vpp-api/python/vpp_papi/vpp_transport_socket.py b/src/vpp-api/python/vpp_papi/vpp_transport_socket.py
index ee142584c..cb1b8cbf1 100644
--- a/src/vpp-api/python/vpp_papi/vpp_transport_socket.py
+++ b/src/vpp-api/python/vpp_papi/vpp_transport_socket.py
@@ -123,6 +123,7 @@ class VppTransport(object):
             raise VppTransportSocketIOError('Invalid reply message')
 
         r, length = sockclnt_create_reply.unpack(msg)
+        logging.info("Got sockclnt_create_reply.")
         self.socket_index = r.index
         for m in r.message_table:
             n = m.name.rstrip(b'\x00\x13')
@@ -152,6 +153,8 @@ class VppTransport(object):
         if self.message_thread is not None and self.message_thread.is_alive():
             # Allow additional connect() calls.
             self.message_thread.join()
+        # Wipe message table, VPP can be restarted with different plugins.
+        self.message_table = {}
         # Collect garbage.
         self.message_thread = None
         self.socket = None
@@ -193,12 +196,14 @@ class VppTransport(object):
 
     def _read(self):
         hdr = self.socket.recv(16)
+        logging.debug("Received header {m!r}".format(m=hdr))
         if not hdr:
             return
         (_, hdrlen, _) = self.header.unpack(hdr)  # If at head of message
 
         # Read rest of message
         msg = self.socket.recv(hdrlen)
+        logging.debug("Received message start {m!r}".format(m=msg))
         if hdrlen > len(msg):
             nbytes = len(msg)
             buf = bytearray(hdrlen)
@@ -208,10 +213,14 @@ class VppTransport(object):
             left = hdrlen - nbytes
             while left:
                 nbytes = self.socket.recv_into(view, left)
+                logging.debug("Received message chunk {m!r}".format(m=view[:nbytes]))
                 view = view[nbytes:]
                 left -= nbytes
+                logging.debug("Left {m!r}".format(m=left))
+            logging.debug("Chunked message done.")
             return buf
         if hdrlen == len(msg):
+            logging.debug("Start message full.")
             return msg
         raise VppTransportSocketIOError(1, 'Unknown socket read error')
 
@@ -219,6 +228,7 @@ class VppTransport(object):
         if not self.connected:
             raise VppTransportSocketIOError(1, 'Not connected')
         try:
-            return self.q.get(True, self.read_timeout)
+            msg = self.q.get(True, self.read_timeout)
+            return msg
         except queue.Empty:
             return None
