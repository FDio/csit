diff --git a/src/vpp-api/python/vpp_papi/vpp_papi.py b/src/vpp-api/python/vpp_papi/vpp_papi.py
index 5207bbf0b..572cda3b0 100644
--- a/src/vpp-api/python/vpp_papi/vpp_papi.py
+++ b/src/vpp-api/python/vpp_papi/vpp_papi.py
@@ -647,21 +647,26 @@ class VPPApiClient(object):
         rl = []
         while (True):
             msg = self.transport.read()
+            logger.debug("Read from transport {r!r}".format(r=msg))
             if not msg:
                 raise VPPIOError(2, 'VPP API client: read failed')
             r = self.decode_incoming_msg(msg, no_type_conversion)
             msgname = type(r).__name__
             if context not in r or r.context == 0 or context != r.context:
                 # Message being queued
+                logger.debug("Message queued {r!r}".format(r=r))
                 self.message_queue.put_nowait(r)
                 continue
 
             if not multipart:
                 rl = r
+                logger.debug("Passing singlepart {r!r}".format(r=r))
                 break
             if msgname == 'control_ping_reply':
+                logger.debug("Got ping reply {r!r}".fomrat(r=r))
                 break
 
+            logger.debug("Appending multipart {r!r}".format(r=r))
             rl.append(r)
 
         self.transport.resume()
@@ -690,6 +695,7 @@ class VPPApiClient(object):
             kwargs['client_index'] = 0
         kwargs['_vl_msg_id'] = i
         b = msg.pack(kwargs)
+        logger.debug("Sending async {b!r}".format(b=b))
 
         self.transport.write(b)
 
diff --git a/src/vpp-api/python/vpp_papi/vpp_transport_socket.py b/src/vpp-api/python/vpp_papi/vpp_transport_socket.py
index ee142584c..bd1aad9f0 100644
--- a/src/vpp-api/python/vpp_papi/vpp_transport_socket.py
+++ b/src/vpp-api/python/vpp_papi/vpp_transport_socket.py
@@ -47,34 +47,39 @@ class VppTransport(object):
             except socket.error:
                 # Terminate thread
                 logging.error('select failed')
-                self.q.put(None)
+                self.q.put((None, []))
                 return
 
             for r in rlist:
                 if r == self.sque._reader:
                     # Terminate
-                    self.q.put(None)
+                    self.q.put((None, []))
                     return
 
                 elif r == self.socket:
                     try:
-                        msg = self._read()
+                        msg, logs = self._read()
                         if not msg:
-                            self.q.put(None)
+                            self.q.put((None, logs))
                             return
                     except socket.error:
-                        self.q.put(None)
+                        self.q.put((None, []))
                         return
                     # Put either to local queue or if context == 0
                     # callback queue
                     if self.parent.has_context(msg):
-                        self.q.put(msg)
+                        self.q.put((msg, logs))
                     else:
                         self.parent.msg_handler_async(msg)
                 else:
                     raise VppTransportSocketIOError(
                         2, 'Unknown response from select')
 
+    @staticmethod
+    def log_logs(logs):
+        for log in logs:
+            logging.debug("Read log: {log}".format(log=log))
+
     def connect(self, name, pfx, msg_handler, rx_qlen):
         # TODO: Reorder the actions and add "roll-backs",
         # to restore clean disconnect state when failure happens durng connect.
@@ -116,13 +121,15 @@ class VppTransport(object):
                 'context': 124}
         b = sockclnt_create.pack(args)
         self.write(b)
-        msg = self._read()
+        msg, logs = self._read()
+        self.log_logs(logs)
         hdr, length = self.parent.header.unpack(msg, 0)
         if hdr.msgid != 16:
             # TODO: Add first numeric argument.
             raise VppTransportSocketIOError('Invalid reply message')
 
         r, length = sockclnt_create_reply.unpack(msg)
+        logging.info("Got sockclnt_create_reply.")
         self.socket_index = r.index
         for m in r.message_table:
             n = m.name.rstrip(b'\x00\x13')
@@ -152,6 +159,8 @@ class VppTransport(object):
         if self.message_thread is not None and self.message_thread.is_alive():
             # Allow additional connect() calls.
             self.message_thread.join()
+        # Wipe message table, VPP can be restarted with different plugins.
+        self.message_table = {}
         # Collect garbage.
         self.message_thread = None
         self.socket = None
@@ -192,13 +201,16 @@ class VppTransport(object):
             raise VppTransportSocketIOError(1, 'Not connected')
 
     def _read(self):
+        logs = []
         hdr = self.socket.recv(16)
+        logs.append("Received header {m!r}".format(m=hdr))
         if not hdr:
-            return
+            return None, logs
         (_, hdrlen, _) = self.header.unpack(hdr)  # If at head of message
 
         # Read rest of message
         msg = self.socket.recv(hdrlen)
+        logs.append("Received message start {m!r}".format(m=msg))
         if hdrlen > len(msg):
             nbytes = len(msg)
             buf = bytearray(hdrlen)
@@ -208,17 +220,23 @@ class VppTransport(object):
             left = hdrlen - nbytes
             while left:
                 nbytes = self.socket.recv_into(view, left)
+                logs.append("Received message chunk {m!r}".format(m=view[:nbytes]))
                 view = view[nbytes:]
                 left -= nbytes
-            return buf
+                logs.append("Left {m!r}".format(m=left))
+            logs.append("Chunked message done.")
+            return buf, logs
         if hdrlen == len(msg):
-            return msg
+            logs.append("Start message full.")
+            return msg, logs
         raise VppTransportSocketIOError(1, 'Unknown socket read error')
 
     def read(self):
         if not self.connected:
             raise VppTransportSocketIOError(1, 'Not connected')
         try:
-            return self.q.get(True, self.read_timeout)
+            msg, logs = self.q.get(True, self.read_timeout)
+            self.log_logs(logs)
+            return msg
         except queue.Empty:
             return None
