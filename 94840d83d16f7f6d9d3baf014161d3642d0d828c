{
  "comments": [
    {
      "key": {
        "uuid": "93105d82_bf084cc4",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 76,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Why is B capitalized? Also, mention our bytes are octets.",
      "range": {
        "startLine": 76,
        "startChar": 44,
        "endLine": 76,
        "endChar": 49
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "323e7657_db13ac72",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 86,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Add Terminology item explaining this abbreviation.",
      "range": {
        "startLine": 86,
        "startChar": 2,
        "endLine": 86,
        "endChar": 9
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8228f69_59739235",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 88,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "In CSIT, the important assumption is that both directions have the same offered load (so bidirectional load is twice that unidirectional load).\nNot sure what would happen for non-symmetric (either only in load or also in profile) tests.",
      "range": {
        "startLine": 88,
        "startChar": 20,
        "endLine": 88,
        "endChar": 21
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "001e2e2a_8289a47f",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 91,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "In CSIT we take case to put the same load on each interface, even on each internal queue. But I believe for abstract MLRsearch it does not matter, as long as offered load and receive rate are aggregates.",
      "range": {
        "startLine": 91,
        "startChar": 37,
        "endLine": 91,
        "endChar": 48
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edc7621f_e5d302d3",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 94,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Already written after \"relative\".",
      "range": {
        "startLine": 93,
        "startChar": 53,
        "endLine": 94,
        "endChar": 13
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "53eecacb_c7a916ed",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 97,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Not true for current MLRsearch implementation.\nWe put aggregates to the formula in lines 95-96.",
      "range": {
        "startLine": 97,
        "startChar": 21,
        "endLine": 97,
        "endChar": 28
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a5a06897_fe6b2d49",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 98,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "offered load DUT/SUT forwards within the",
      "range": {
        "startLine": 98,
        "startChar": 34,
        "endLine": 98,
        "endChar": 69
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a76fd0d6_bae8601c",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 100,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "by",
      "range": {
        "startLine": 100,
        "startChar": 27,
        "endLine": 100,
        "endChar": 30
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ebcd2ef1_2ad8624f",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 103,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Current MLRsearch implementation finds only aggregate ofered load. It is up to traffic generator how it divides the load over directions, MLRsearch has no visibility into that.\nReporting unidirectional values can be useful if the test guarantees both directions are loaded equally, and the goal of the test does not care if directions do not show the same loss ratio.",
      "range": {
        "startLine": 103,
        "startChar": 54,
        "endLine": 103,
        "endChar": 64
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "05a8c3e9_69007807",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 117,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Possible, but not implemented. CSIT implementation looks at aggregates only.",
      "range": {
        "startLine": 117,
        "startChar": 10,
        "endLine": 117,
        "endChar": 43
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5457f37a_1a5e15ef",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 118,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Ah, that is what that paragraph on curves was about.\nI would just note that having min and max offered load guarantees the algorithm converges, and that for irregular curves the limitations are the same as for binary search (there may be multiple loads satisfying PLR conditions, and the algo may converge to one of limit load values instead finding one).",
      "parentUuid": "8c3dadba_57532c64",
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b238ce3c_133a740a",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 127,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Forwarding? Receive? Definitely not throughput as defined above.",
      "range": {
        "startLine": 127,
        "startChar": 47,
        "endLine": 127,
        "endChar": 57
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ef24783f_03292f84",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 136,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Throughput is the quantity MLRsearch is searching for using multiple trial measurements. Single trial measurement can have offered load unrelated to that final quantity.\nLook at https://tools.ietf.org/html/rfc2544#section-23 for a better description.",
      "range": {
        "startLine": 136,
        "startChar": 18,
        "endLine": 136,
        "endChar": 28
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc00bf16_54d632c7",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 157,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "results for deterministic systems\n\n\"similar\" sounds too vague.",
      "range": {
        "startLine": 156,
        "startChar": 55,
        "endLine": 157,
        "endChar": 7
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8733977a_e20e27c0",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 163,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "adapted\n\nAlso, we probably should describe such adapted algorithm (in next draft version).",
      "range": {
        "startLine": 163,
        "startChar": 0,
        "endLine": 163,
        "endChar": 7
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8125dcf2_87dbf985",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 168,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "increasing? Perhaps remove 166-169, as I am not sure what is considered effective for sometimes-decreasing curves.",
      "range": {
        "startLine": 168,
        "startChar": 24,
        "endLine": 168,
        "endChar": 33
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b50f650a_c76382d8",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 173,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "are",
      "range": {
        "startLine": 173,
        "startChar": 6,
        "endLine": 173,
        "endChar": 7
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc7406dd_bd582f29",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 207,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "In later version, we may rename the values, just to avoid confusion aroun what \"invalid bound\" is. I just do not have good enough names right now.",
      "range": {
        "startLine": 207,
        "startChar": 28,
        "endLine": 207,
        "endChar": 39
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5c9f3072_1bf9f935",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 230,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Two things not mentioned in this version.\nAside of initial phase, the only way for a bound to become invalid is when it is re-measured at higher trial duration.\nEach non-initial phase needs to re-measure before returning, as short duration results are not trusted.",
      "range": {
        "startLine": 230,
        "startChar": 25,
        "endLine": 230,
        "endChar": 41
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50ff3e4a_f4e571af",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Line 306 has MRR, pick one capitalization.",
      "range": {
        "startLine": 303,
        "startChar": 10,
        "endLine": 303,
        "endChar": 13
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ef2cd625_98695ff3",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 312,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Actually, the current implementation has some logic here. If MRR2 is too close to MRR (and loss ratio from line 308 is nonzero), we take a lower value (to hit the width goal of first intermediate phase). Similarly if 308 ratio is zero, we measure at value increased (also to hit the width goal). That is because having too narrow interval can cause unnecessary external search in later phases (especially final phase in worst case).\nNot sure how detailed our description should be with respect to such details.",
      "range": {
        "startLine": 312,
        "startChar": 33,
        "endLine": 312,
        "endChar": 37
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb979531_18280e23",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 360,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "... or the amount needed to hit the current width goal, whichever is larger.\n\nA small optimization in case the initial interval was too narrow due to max (or min) rate limit being hit.\nApplies to othe 2.a items as well.\nAnd of course, the new transmit rate is set to min or max rate if the computed value would overstep the limit.",
      "range": {
        "startLine": 360,
        "startChar": 40,
        "endLine": 360,
        "endChar": 63
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ae2eda59_7492733c",
        "filename": "docs/ietf/draft-vpolak-mkonstan-bmwg-mlrsearch-02.md",
        "patchSetId": 2
      },
      "lineNbr": 375,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-07-03T17:55:10Z",
      "side": 1,
      "message": "Actually, the geometric average is used in the CSIT implementation. Otherwise the new half-intervals would have different relative width (same absolute width, but relative to different upper bound).\nAn implementation with arithmetic average and absolute width goal is equally possible. But in CSIT we have chosen relative quantities so our parameters choices do not depend on line rate not expected throughput.",
      "range": {
        "startLine": 374,
        "startChar": 68,
        "endLine": 375,
        "endChar": 42
      },
      "revId": "94840d83d16f7f6d9d3baf014161d3642d0d828c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    }
  ]
}