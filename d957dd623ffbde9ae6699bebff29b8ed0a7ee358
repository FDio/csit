{
  "comments": [
    {
      "key": {
        "uuid": "617a7711_e5febc5b",
        "filename": "resources/libraries/python/PapiExecutor.py",
        "patchSetId": 3
      },
      "lineNbr": 196,
      "author": {
        "id": 207
      },
      "writtenOn": "2019-04-08T11:34:55Z",
      "side": 1,
      "message": "It would be usefull to allow import function for processing dump data, e.g. https://gerrit.fd.io/r/#/c/18360/26/resources/libraries/python/InterfaceUtil.py@289.",
      "range": {
        "startLine": 195,
        "startChar": 20,
        "endLine": 196,
        "endChar": 57
      },
      "revId": "d957dd623ffbde9ae6699bebff29b8ed0a7ee358",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "45733074_0afd91dc",
        "filename": "resources/libraries/python/PapiExecutor.py",
        "patchSetId": 3
      },
      "lineNbr": 196,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-04-08T17:08:31Z",
      "side": 1,
      "message": "I agree we should simplify and hide the type manipulations, but I do not think this method is the correct place to do that.\n\nBasically, we have a design mismatch. When we were designing the communication \"protocol\" between Robot and SUT, we used JSON because it is human readable. But we did not anticipate PAPI to start switching from simple types (integer and string/bytes) to structured types (MAC, IP4, various enums).\n\nWith structured types, we now have SSOT violation. The SUT utility has direct access to PAPI types and instances. But it needs to convert them to ints and strs for json, and on Robot side we have stuff like L2VtrOp and bin_to_mac().\n\nSome conversion is inevitable. For example, Robot tests need \"de:ad:be:ef:13:37\" form of MAC addresses for readability, and PAPI is right for defining specific classes (for example for validation reasons). But I believe we should perform such conversions at most once.\n\nThat implies two decisions. First, do we want to use sophisticated types on Robot side? I vote for \"no\", but perhaps I am missing some consequence here.\nIf we vote for \"no\", I believe the SUT utility should do all the conversions needed, as it has the access to PAPI types, and we can keep the readable JSON communication.\n\nBut if we vote \"yes\", the second decision is how to transfer the typed instances. Here I vote for \"use a third party library to restore the same typed objects on Robot side\". That means either pickle, or something more powerful (dill).\nWe probably lose the human-readability of the transferred data, but this way we can be sure the objects on the Robot side are the same type as on the SUT side (so we do not care about PAPI changes that much, if duck typing still works).\n\nI just dislike the way in which CSIT would have to maintain its own type definitions in parallel to the PAPI ones.",
      "parentUuid": "617a7711_e5febc5b",
      "range": {
        "startLine": 195,
        "startChar": 20,
        "endLine": 196,
        "endChar": 57
      },
      "revId": "d957dd623ffbde9ae6699bebff29b8ed0a7ee358",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f19d3e31_452c6bf6",
        "filename": "resources/libraries/python/PapiExecutor.py",
        "patchSetId": 3
      },
      "lineNbr": 196,
      "author": {
        "id": 76
      },
      "writtenOn": "2019-04-09T06:42:08Z",
      "side": 1,
      "message": "You summarize it very well.\nBut there are more caveats with \"yes\" and that is how frequently it will change. It can lead to huge problem maintaining the code whenever the VPP will change data types (and trust me, from ligato I know this very often). This can be harmful. The rest is just natural complexity of pickling and as you said readability is near 0. \n\nThe only solution i think is to convince the VPP developers to in source PAPI_provider.py and implement single interface to outside. Which in fact is in contradiction to the original idea to have Python API.\n\nSecond option is really to use remote sockets and remove JSON entirely. Run the PAPI locally from executor node (jenkins) and use the types, but I scared how many times it will change until they converge to something stable.",
      "parentUuid": "45733074_0afd91dc",
      "range": {
        "startLine": 195,
        "startChar": 20,
        "endLine": 196,
        "endChar": 57
      },
      "revId": "d957dd623ffbde9ae6699bebff29b8ed0a7ee358",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c261b180_b20c9101",
        "filename": "resources/libraries/python/PapiExecutor.py",
        "patchSetId": 3
      },
      "lineNbr": 196,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-04-09T08:32:57Z",
      "side": 1,
      "message": "Yeah, unix socket over SSH tunnel is similar to pickle. Third party, should work, but the transferred data is not readable.\n\nIf we go this \"yes\" way, ideally all PAPI classes would implement a nice __repr__() so we can at least log the objects on the Robot side in a readable form.\n\nI still prefer the \"no\" way, but perhaps I will change mi mind when I see a more complicated object, such as ACL, policy, or something like that.",
      "parentUuid": "f19d3e31_452c6bf6",
      "range": {
        "startLine": 195,
        "startChar": 20,
        "endLine": 196,
        "endChar": 57
      },
      "revId": "d957dd623ffbde9ae6699bebff29b8ed0a7ee358",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7463ebb2_c78a478d",
        "filename": "resources/libraries/python/PapiExecutor.py",
        "patchSetId": 3
      },
      "lineNbr": 196,
      "author": {
        "id": 76
      },
      "writtenOn": "2019-04-09T09:40:59Z",
      "side": 1,
      "message": "Well there is another problem where \"yes\" does make sense and it is not an easy way to avoid.\n\nCurrently if we want to papi to container, it is a problem for CSIT. And there is raised demand (requests) to implement PAPI to be able to control CNF or VSWITCH that runs in container. For that we have to be able to connect to multiple sockets.\n\nAs of today I did not check if we are able to run multiple PAPIExecutors each on different socket. We are able to share socket out of container to \"host OS\" but how to create multiple histories and multiple papi executors. Etc.\n\nSo i think we need to get back to design table to be able to address the issue we have with current design.",
      "parentUuid": "c261b180_b20c9101",
      "range": {
        "startLine": 195,
        "startChar": 20,
        "endLine": 196,
        "endChar": 57
      },
      "revId": "d957dd623ffbde9ae6699bebff29b8ed0a7ee358",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5cb353f7_02fa6c17",
        "filename": "resources/libraries/python/PapiExecutor.py",
        "patchSetId": 3
      },
      "lineNbr": 196,
      "author": {
        "id": 1263
      },
      "writtenOn": "2019-04-09T10:37:18Z",
      "side": 1,
      "message": "Long post, I wanted to just add a quick comment, but I slowly ended up writing a design.\n\nCurrently we have three ways how could VPP be placed on a SUT. Bare metal, container, or VM.\nDo we currently interact with a VM-placed VPP in runtime? I believe the standard way would be to have a SSH server running inside the VM and connect there from Robot machine (IP address of the host OS, different TCP port number so host OS knows which VM to redirect to).\n\nI agree that for containers, exposing the socket to host OS is the correct way. Here is where \"unix socket over SSH\" is simpler than Python script on SUT, as we can use TCP port number again to distinguish which socket do we want to connect to.\n\nThis is actually nice. SUT is defined by an IP address, DUT is defined by an IP address and a TCP port number. If we want to collect som \"external\" telemetry inside a VM/container, we can assign another TCP port number for Bash there.\nTG will have only this, no unix socket.\nAbstractly speaking, from Robot point of view, everything will be a SSH endpoint. Some endpoints lead to Bash, some lead to unix socket of VPP. Each \"node\" in topology has MetalBash enpoint by default, ant at runtime it will be possible to create VirtualBash, MetalSocket or VirtualSocket (most actions do not care whether a particular endpoint is Metal or Virtual).\n\nUnfortunately, when CSIT code mentions a Node, it usually means SUT (with physical links to other boxes defined in topology). But in some cases (like NodePath.py) it would be better if a Node was a DUT instead (with some virtual links created at runtime).\nI am not sure how would device jobs fit there.\n\nOh, but I just wanted to make a point that currently PapiExecutor executes each command in \"connect, execute, disconnect\" fashion, so we do not really need to examine whether multiple executors could work in parallel.\n\nAnd PapiHistory is already a single module with a single dict where node[\u0027host\u0027] (should be be DUT) is key.",
      "parentUuid": "7463ebb2_c78a478d",
      "range": {
        "startLine": 195,
        "startChar": 20,
        "endLine": 196,
        "endChar": 57
      },
      "revId": "d957dd623ffbde9ae6699bebff29b8ed0a7ee358",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    }
  ]
}